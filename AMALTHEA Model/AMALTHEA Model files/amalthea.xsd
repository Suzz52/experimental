<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:am="http://app4mc.eclipse.org/amalthea/3.3.0" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ecore:nsPrefix="am" ecore:package="org.eclipse.app4mc.amalthea.model" targetNamespace="http://app4mc.eclipse.org/amalthea/3.3.0">
  <xsd:import namespace="http://www.eclipse.org/emf/2002/Ecore" schemaLocation="platform:/plugin/org.eclipse.emf.ecore/model/Ecore.xsd"/>
  <xsd:annotation>
    <xsd:documentation>*
*******************************************************************************
Copyright (c) 2015-2024 Robert Bosch GmbH and others.

This program and the accompanying materials are made
available under the terms of the Eclipse Public License 2.0
which is available at https://www.eclipse.org/legal/epl-2.0/

SPDX-License-Identifier: EPL-2.0
*******************************************************************************</xsd:documentation>
  </xsd:annotation>
  <xsd:element ecore:ignore="true" name="Amalthea" type="am:Amalthea"/>
  <xsd:element ecore:ignore="true" name="CommonElements" type="am:CommonElements"/>
  <xsd:element ecore:ignore="true" name="BaseObject" type="am:BaseObject"/>
  <xsd:element ecore:ignore="true" name="ReferableObject" type="am:ReferableObject"/>
  <xsd:element ecore:ignore="true" name="ReferableBaseObject" type="am:ReferableBaseObject"/>
  <xsd:element ecore:ignore="true" name="IAnnotatable" type="am:IAnnotatable"/>
  <xsd:element ecore:ignore="true" name="ITaggable" type="am:ITaggable"/>
  <xsd:element ecore:ignore="true" name="INamed" type="am:INamed"/>
  <xsd:element ecore:ignore="true" name="IReferable" type="am:IReferable"/>
  <xsd:element ecore:ignore="true" name="IDisplayName" type="am:IDisplayName"/>
  <xsd:element ecore:ignore="true" name="IDescription" type="am:IDescription"/>
  <xsd:element ecore:ignore="true" name="INamespaceMember" type="am:INamespaceMember"/>
  <xsd:element ecore:ignore="true" name="Tag" type="am:Tag"/>
  <xsd:element ecore:ignore="true" name="Namespace" type="am:Namespace"/>
  <xsd:element ecore:ignore="true" name="Classifier" type="am:Classifier"/>
  <xsd:element ecore:ignore="true" name="CoreClassifier" type="am:CoreClassifier"/>
  <xsd:element ecore:ignore="true" name="MemoryClassifier" type="am:MemoryClassifier"/>
  <xsd:element ecore:ignore="true" name="TransmissionPolicy" type="am:TransmissionPolicy"/>
  <xsd:element ecore:ignore="true" name="Quantity" type="am:Quantity"/>
  <xsd:element ecore:ignore="true" name="TimeComparable" type="am:TimeComparable"/>
  <xsd:element ecore:ignore="true" name="Time" type="am:Time"/>
  <xsd:element ecore:ignore="true" name="Frequency" type="am:Frequency"/>
  <xsd:element ecore:ignore="true" name="Voltage" type="am:Voltage"/>
  <xsd:element ecore:ignore="true" name="DataSize" type="am:DataSize"/>
  <xsd:element ecore:ignore="true" name="DataRateComparable" type="am:DataRateComparable"/>
  <xsd:element ecore:ignore="true" name="DataRate" type="am:DataRate"/>
  <xsd:element ecore:ignore="true" name="CustomProperty" type="am:CustomProperty"/>
  <xsd:element ecore:ignore="true" name="Value" type="am:Value"/>
  <xsd:element ecore:ignore="true" name="ListObject" type="am:ListObject"/>
  <xsd:element ecore:ignore="true" name="MapObject" type="am:MapObject"/>
  <xsd:element ecore:ignore="true" name="StringObject" type="am:StringObject"/>
  <xsd:element ecore:ignore="true" name="BigIntegerObject" type="am:BigIntegerObject"/>
  <xsd:element ecore:ignore="true" name="ReferenceObject" type="am:ReferenceObject"/>
  <xsd:element ecore:ignore="true" name="IntegerObject" type="am:IntegerObject"/>
  <xsd:element ecore:ignore="true" name="LongObject" type="am:LongObject"/>
  <xsd:element ecore:ignore="true" name="FloatObject" type="am:FloatObject"/>
  <xsd:element ecore:ignore="true" name="DoubleObject" type="am:DoubleObject"/>
  <xsd:element ecore:ignore="true" name="BooleanObject" type="am:BooleanObject"/>
  <xsd:element ecore:ignore="true" name="NumericStatistic" type="am:NumericStatistic"/>
  <xsd:element ecore:ignore="true" name="MinAvgMaxStatistic" type="am:MinAvgMaxStatistic"/>
  <xsd:element ecore:ignore="true" name="SingleValueStatistic" type="am:SingleValueStatistic"/>
  <xsd:element ecore:ignore="true" name="ITimeDeviation" type="am:ITimeDeviation"/>
  <xsd:element ecore:ignore="true" name="TimeInterval" type="am:TimeInterval"/>
  <xsd:element ecore:ignore="true" name="TimeConstant" type="am:TimeConstant"/>
  <xsd:element ecore:ignore="true" name="TimeHistogram" type="am:TimeHistogram"/>
  <xsd:element ecore:ignore="true" name="TimeHistogramEntry" type="am:TimeHistogramEntry"/>
  <xsd:element ecore:ignore="true" name="BoundedTimeDistribution" type="am:BoundedTimeDistribution"/>
  <xsd:element ecore:ignore="true" name="TruncatedTimeDistribution" type="am:TruncatedTimeDistribution"/>
  <xsd:element ecore:ignore="true" name="TimeBoundaries" type="am:TimeBoundaries"/>
  <xsd:element ecore:ignore="true" name="TimeStatistics" type="am:TimeStatistics"/>
  <xsd:element ecore:ignore="true" name="TimeUniformDistribution" type="am:TimeUniformDistribution"/>
  <xsd:element ecore:ignore="true" name="TimeGaussDistribution" type="am:TimeGaussDistribution"/>
  <xsd:element ecore:ignore="true" name="TimeWeibullEstimatorsDistribution" type="am:TimeWeibullEstimatorsDistribution"/>
  <xsd:element ecore:ignore="true" name="TimeBetaDistribution" type="am:TimeBetaDistribution"/>
  <xsd:element ecore:ignore="true" name="IDiscreteValueDeviation" type="am:IDiscreteValueDeviation"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueInterval" type="am:DiscreteValueInterval"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueConstant" type="am:DiscreteValueConstant"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueHistogram" type="am:DiscreteValueHistogram"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueHistogramEntry" type="am:DiscreteValueHistogramEntry"/>
  <xsd:element ecore:ignore="true" name="BoundedDiscreteValueDistribution" type="am:BoundedDiscreteValueDistribution"/>
  <xsd:element ecore:ignore="true" name="TruncatedDiscreteValueDistribution" type="am:TruncatedDiscreteValueDistribution"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueBoundaries" type="am:DiscreteValueBoundaries"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueStatistics" type="am:DiscreteValueStatistics"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueUniformDistribution" type="am:DiscreteValueUniformDistribution"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueGaussDistribution" type="am:DiscreteValueGaussDistribution"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueWeibullEstimatorsDistribution" type="am:DiscreteValueWeibullEstimatorsDistribution"/>
  <xsd:element ecore:ignore="true" name="DiscreteValueBetaDistribution" type="am:DiscreteValueBetaDistribution"/>
  <xsd:element ecore:ignore="true" name="IContinuousValueDeviation" type="am:IContinuousValueDeviation"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueInterval" type="am:ContinuousValueInterval"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueConstant" type="am:ContinuousValueConstant"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueHistogram" type="am:ContinuousValueHistogram"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueHistogramEntry" type="am:ContinuousValueHistogramEntry"/>
  <xsd:element ecore:ignore="true" name="BoundedContinuousValueDistribution" type="am:BoundedContinuousValueDistribution"/>
  <xsd:element ecore:ignore="true" name="TruncatedContinuousValueDistribution" type="am:TruncatedContinuousValueDistribution"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueBoundaries" type="am:ContinuousValueBoundaries"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueStatistics" type="am:ContinuousValueStatistics"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueUniformDistribution" type="am:ContinuousValueUniformDistribution"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueGaussDistribution" type="am:ContinuousValueGaussDistribution"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueWeibullEstimatorsDistribution" type="am:ContinuousValueWeibullEstimatorsDistribution"/>
  <xsd:element ecore:ignore="true" name="ContinuousValueBetaDistribution" type="am:ContinuousValueBetaDistribution"/>
  <xsd:element ecore:ignore="true" name="Mode" type="am:Mode"/>
  <xsd:element ecore:ignore="true" name="NumericMode" type="am:NumericMode"/>
  <xsd:element ecore:ignore="true" name="EnumMode" type="am:EnumMode"/>
  <xsd:element ecore:ignore="true" name="ModeLiteral" type="am:ModeLiteral"/>
  <xsd:element ecore:ignore="true" name="ComponentsModel" type="am:ComponentsModel"/>
  <xsd:element ecore:ignore="true" name="IComponentContainer" type="am:IComponentContainer"/>
  <xsd:element ecore:ignore="true" name="IInterfaceContainer" type="am:IInterfaceContainer"/>
  <xsd:element ecore:ignore="true" name="ISystem" type="am:ISystem"/>
  <xsd:element ecore:ignore="true" name="ComponentInterface" type="am:ComponentInterface"/>
  <xsd:element ecore:ignore="true" name="MainInterface" type="am:MainInterface"/>
  <xsd:element ecore:ignore="true" name="SubInterface" type="am:SubInterface"/>
  <xsd:element ecore:ignore="true" name="ComponentPort" type="am:ComponentPort"/>
  <xsd:element ecore:ignore="true" name="ComponentStructure" type="am:ComponentStructure"/>
  <xsd:element ecore:ignore="true" name="IComponentStructureMember" type="am:IComponentStructureMember"/>
  <xsd:element ecore:ignore="true" name="Component" type="am:Component"/>
  <xsd:element ecore:ignore="true" name="Composite" type="am:Composite"/>
  <xsd:element ecore:ignore="true" name="System" type="am:System"/>
  <xsd:element ecore:ignore="true" name="ComponentInstance" type="am:ComponentInstance"/>
  <xsd:element ecore:ignore="true" name="Connector" type="am:Connector"/>
  <xsd:element ecore:ignore="true" name="InterfaceChannel" type="am:InterfaceChannel"/>
  <xsd:element ecore:ignore="true" name="QualifiedPort" type="am:QualifiedPort"/>
  <xsd:element ecore:ignore="true" name="ConfigModel" type="am:ConfigModel"/>
  <xsd:element ecore:ignore="true" name="EventConfig" type="am:EventConfig"/>
  <xsd:element ecore:ignore="true" name="ConstraintsModel" type="am:ConstraintsModel"/>
  <xsd:element ecore:ignore="true" name="RunnableSequencingConstraint" type="am:RunnableSequencingConstraint"/>
  <xsd:element ecore:ignore="true" name="AffinityConstraint" type="am:AffinityConstraint"/>
  <xsd:element ecore:ignore="true" name="SeparationConstraint" type="am:SeparationConstraint"/>
  <xsd:element ecore:ignore="true" name="PairingConstraint" type="am:PairingConstraint"/>
  <xsd:element ecore:ignore="true" name="ProcessConstraint" type="am:ProcessConstraint"/>
  <xsd:element ecore:ignore="true" name="RunnableConstraint" type="am:RunnableConstraint"/>
  <xsd:element ecore:ignore="true" name="DataConstraint" type="am:DataConstraint"/>
  <xsd:element ecore:ignore="true" name="RunnableSeparationConstraint" type="am:RunnableSeparationConstraint"/>
  <xsd:element ecore:ignore="true" name="ProcessSeparationConstraint" type="am:ProcessSeparationConstraint"/>
  <xsd:element ecore:ignore="true" name="DataSeparationConstraint" type="am:DataSeparationConstraint"/>
  <xsd:element ecore:ignore="true" name="RunnablePairingConstraint" type="am:RunnablePairingConstraint"/>
  <xsd:element ecore:ignore="true" name="ProcessPairingConstraint" type="am:ProcessPairingConstraint"/>
  <xsd:element ecore:ignore="true" name="DataPairingConstraint" type="am:DataPairingConstraint"/>
  <xsd:element ecore:ignore="true" name="RunnableConstraintTarget" type="am:RunnableConstraintTarget"/>
  <xsd:element ecore:ignore="true" name="ProcessConstraintTarget" type="am:ProcessConstraintTarget"/>
  <xsd:element ecore:ignore="true" name="DataConstraintTarget" type="am:DataConstraintTarget"/>
  <xsd:element ecore:ignore="true" name="TargetMemory" type="am:TargetMemory"/>
  <xsd:element ecore:ignore="true" name="TargetCore" type="am:TargetCore"/>
  <xsd:element ecore:ignore="true" name="TargetScheduler" type="am:TargetScheduler"/>
  <xsd:element ecore:ignore="true" name="LabelGroup" type="am:LabelGroup"/>
  <xsd:element ecore:ignore="true" name="RunnableGroup" type="am:RunnableGroup"/>
  <xsd:element ecore:ignore="true" name="ProcessGroup" type="am:ProcessGroup"/>
  <xsd:element ecore:ignore="true" name="LabelEntityGroup" type="am:LabelEntityGroup"/>
  <xsd:element ecore:ignore="true" name="RunnableEntityGroup" type="am:RunnableEntityGroup"/>
  <xsd:element ecore:ignore="true" name="ProcessEntityGroup" type="am:ProcessEntityGroup"/>
  <xsd:element ecore:ignore="true" name="TagGroup" type="am:TagGroup"/>
  <xsd:element ecore:ignore="true" name="AbstractEventChain" type="am:AbstractEventChain"/>
  <xsd:element ecore:ignore="true" name="EventChain" type="am:EventChain"/>
  <xsd:element ecore:ignore="true" name="SubEventChain" type="am:SubEventChain"/>
  <xsd:element ecore:ignore="true" name="EventChainItem" type="am:EventChainItem"/>
  <xsd:element ecore:ignore="true" name="EventChainReference" type="am:EventChainReference"/>
  <xsd:element ecore:ignore="true" name="EventChainContainer" type="am:EventChainContainer"/>
  <xsd:element ecore:ignore="true" name="TimingConstraint" type="am:TimingConstraint"/>
  <xsd:element ecore:ignore="true" name="PhysicalSectionConstraint" type="am:PhysicalSectionConstraint"/>
  <xsd:element ecore:ignore="true" name="SynchronizationConstraint" type="am:SynchronizationConstraint"/>
  <xsd:element ecore:ignore="true" name="EventSynchronizationConstraint" type="am:EventSynchronizationConstraint"/>
  <xsd:element ecore:ignore="true" name="EventChainSynchronizationConstraint" type="am:EventChainSynchronizationConstraint"/>
  <xsd:element ecore:ignore="true" name="DelayConstraint" type="am:DelayConstraint"/>
  <xsd:element ecore:ignore="true" name="EventChainLatencyConstraint" type="am:EventChainLatencyConstraint"/>
  <xsd:element ecore:ignore="true" name="RepetitionConstraint" type="am:RepetitionConstraint"/>
  <xsd:element ecore:ignore="true" name="DataAgeConstraint" type="am:DataAgeConstraint"/>
  <xsd:element ecore:ignore="true" name="DataAge" type="am:DataAge"/>
  <xsd:element ecore:ignore="true" name="DataAgeCycle" type="am:DataAgeCycle"/>
  <xsd:element ecore:ignore="true" name="DataAgeTime" type="am:DataAgeTime"/>
  <xsd:element ecore:ignore="true" name="Requirement" type="am:Requirement"/>
  <xsd:element ecore:ignore="true" name="ProcessRequirement" type="am:ProcessRequirement"/>
  <xsd:element ecore:ignore="true" name="RunnableRequirement" type="am:RunnableRequirement"/>
  <xsd:element ecore:ignore="true" name="ArchitectureRequirement" type="am:ArchitectureRequirement"/>
  <xsd:element ecore:ignore="true" name="ProcessChainRequirement" type="am:ProcessChainRequirement"/>
  <xsd:element ecore:ignore="true" name="RequirementLimit" type="am:RequirementLimit"/>
  <xsd:element ecore:ignore="true" name="CPUPercentageRequirementLimit" type="am:CPUPercentageRequirementLimit"/>
  <xsd:element ecore:ignore="true" name="FrequencyRequirementLimit" type="am:FrequencyRequirementLimit"/>
  <xsd:element ecore:ignore="true" name="PercentageRequirementLimit" type="am:PercentageRequirementLimit"/>
  <xsd:element ecore:ignore="true" name="CountRequirementLimit" type="am:CountRequirementLimit"/>
  <xsd:element ecore:ignore="true" name="TimeRequirementLimit" type="am:TimeRequirementLimit"/>
  <xsd:element ecore:ignore="true" name="DataCoherencyGroup" type="am:DataCoherencyGroup"/>
  <xsd:element ecore:ignore="true" name="DataStabilityGroup" type="am:DataStabilityGroup"/>
  <xsd:element ecore:ignore="true" name="DataGroupScope" type="am:DataGroupScope"/>
  <xsd:element ecore:ignore="true" name="ProcessScope" type="am:ProcessScope"/>
  <xsd:element ecore:ignore="true" name="RunnableScope" type="am:RunnableScope"/>
  <xsd:element ecore:ignore="true" name="ComponentScope" type="am:ComponentScope"/>
  <xsd:element ecore:ignore="true" name="EventModel" type="am:EventModel"/>
  <xsd:element ecore:ignore="true" name="Event" type="am:Event"/>
  <xsd:element ecore:ignore="true" name="EventSet" type="am:EventSet"/>
  <xsd:element ecore:ignore="true" name="EntityEvent" type="am:EntityEvent"/>
  <xsd:element ecore:ignore="true" name="TriggerEvent" type="am:TriggerEvent"/>
  <xsd:element ecore:ignore="true" name="CustomEvent" type="am:CustomEvent"/>
  <xsd:element ecore:ignore="true" name="StimulusEvent" type="am:StimulusEvent"/>
  <xsd:element ecore:ignore="true" name="ProcessEvent" type="am:ProcessEvent"/>
  <xsd:element ecore:ignore="true" name="ProcessChainEvent" type="am:ProcessChainEvent"/>
  <xsd:element ecore:ignore="true" name="RunnableEvent" type="am:RunnableEvent"/>
  <xsd:element ecore:ignore="true" name="LabelEvent" type="am:LabelEvent"/>
  <xsd:element ecore:ignore="true" name="ModeLabelEvent" type="am:ModeLabelEvent"/>
  <xsd:element ecore:ignore="true" name="ChannelEvent" type="am:ChannelEvent"/>
  <xsd:element ecore:ignore="true" name="SemaphoreEvent" type="am:SemaphoreEvent"/>
  <xsd:element ecore:ignore="true" name="ComponentEvent" type="am:ComponentEvent"/>
  <xsd:element ecore:ignore="true" name="HWModel" type="am:HWModel"/>
  <xsd:element ecore:ignore="true" name="HwStructure" type="am:HwStructure"/>
  <xsd:element ecore:ignore="true" name="HwModule" type="am:HwModule"/>
  <xsd:element ecore:ignore="true" name="HwDomain" type="am:HwDomain"/>
  <xsd:element ecore:ignore="true" name="FrequencyDomain" type="am:FrequencyDomain"/>
  <xsd:element ecore:ignore="true" name="PowerDomain" type="am:PowerDomain"/>
  <xsd:element ecore:ignore="true" name="ProcessingUnit" type="am:ProcessingUnit"/>
  <xsd:element ecore:ignore="true" name="Memory" type="am:Memory"/>
  <xsd:element ecore:ignore="true" name="Cache" type="am:Cache"/>
  <xsd:element ecore:ignore="true" name="HwFeatureCategory" type="am:HwFeatureCategory"/>
  <xsd:element ecore:ignore="true" name="HwFeature" type="am:HwFeature"/>
  <xsd:element ecore:ignore="true" name="HwPort" type="am:HwPort"/>
  <xsd:element ecore:ignore="true" name="ConnectionHandler" type="am:ConnectionHandler"/>
  <xsd:element ecore:ignore="true" name="HwConnection" type="am:HwConnection"/>
  <xsd:element ecore:ignore="true" name="HwAccessElement" type="am:HwAccessElement"/>
  <xsd:element ecore:ignore="true" name="HwDefinition" type="am:HwDefinition"/>
  <xsd:element ecore:ignore="true" name="ProcessingUnitDefinition" type="am:ProcessingUnitDefinition"/>
  <xsd:element ecore:ignore="true" name="ConnectionHandlerDefinition" type="am:ConnectionHandlerDefinition"/>
  <xsd:element ecore:ignore="true" name="MemoryDefinition" type="am:MemoryDefinition"/>
  <xsd:element ecore:ignore="true" name="CacheDefinition" type="am:CacheDefinition"/>
  <xsd:element ecore:ignore="true" name="HwPath" type="am:HwPath"/>
  <xsd:element ecore:ignore="true" name="HwAccessPath" type="am:HwAccessPath"/>
  <xsd:element ecore:ignore="true" name="HwPathElement" type="am:HwPathElement"/>
  <xsd:element ecore:ignore="true" name="HwDestination" type="am:HwDestination"/>
  <xsd:element ecore:ignore="true" name="MappingModel" type="am:MappingModel"/>
  <xsd:element ecore:ignore="true" name="SchedulerAllocation" type="am:SchedulerAllocation"/>
  <xsd:element ecore:ignore="true" name="TaskAllocation" type="am:TaskAllocation"/>
  <xsd:element ecore:ignore="true" name="ISRAllocation" type="am:ISRAllocation"/>
  <xsd:element ecore:ignore="true" name="RunnableAllocation" type="am:RunnableAllocation"/>
  <xsd:element ecore:ignore="true" name="MemoryMapping" type="am:MemoryMapping"/>
  <xsd:element ecore:ignore="true" name="PhysicalSectionMapping" type="am:PhysicalSectionMapping"/>
  <xsd:element ecore:ignore="true" name="OSModel" type="am:OSModel"/>
  <xsd:element ecore:ignore="true" name="OsDataConsistency" type="am:OsDataConsistency"/>
  <xsd:element ecore:ignore="true" name="DataStability" type="am:DataStability"/>
  <xsd:element ecore:ignore="true" name="NonAtomicDataCoherency" type="am:NonAtomicDataCoherency"/>
  <xsd:element ecore:ignore="true" name="Semaphore" type="am:Semaphore"/>
  <xsd:element ecore:ignore="true" name="Scheduler" type="am:Scheduler"/>
  <xsd:element ecore:ignore="true" name="TaskScheduler" type="am:TaskScheduler"/>
  <xsd:element ecore:ignore="true" name="SchedulerAssociation" type="am:SchedulerAssociation"/>
  <xsd:element ecore:ignore="true" name="InterruptController" type="am:InterruptController"/>
  <xsd:element ecore:ignore="true" name="OsDefinition" type="am:OsDefinition"/>
  <xsd:element ecore:ignore="true" name="SchedulerDefinition" type="am:SchedulerDefinition"/>
  <xsd:element ecore:ignore="true" name="SchedulingParameterDefinition" type="am:SchedulingParameterDefinition"/>
  <xsd:element ecore:ignore="true" name="ISchedulingParameterContainer" type="am:ISchedulingParameterContainer"/>
  <xsd:element ecore:ignore="true" name="SchedulingParameter" type="am:SchedulingParameter"/>
  <xsd:element ecore:ignore="true" name="OsOverhead" type="am:OsOverhead"/>
  <xsd:element ecore:ignore="true" name="OsAPIOverhead" type="am:OsAPIOverhead"/>
  <xsd:element ecore:ignore="true" name="OsISROverhead" type="am:OsISROverhead"/>
  <xsd:element ecore:ignore="true" name="OperatingSystem" type="am:OperatingSystem"/>
  <xsd:element ecore:ignore="true" name="VendorOperatingSystem" type="am:VendorOperatingSystem"/>
  <xsd:element ecore:ignore="true" name="PropertyConstraintsModel" type="am:PropertyConstraintsModel"/>
  <xsd:element ecore:ignore="true" name="CoreAllocationConstraint" type="am:CoreAllocationConstraint"/>
  <xsd:element ecore:ignore="true" name="MemoryMappingConstraint" type="am:MemoryMappingConstraint"/>
  <xsd:element ecore:ignore="true" name="ProcessAllocationConstraint" type="am:ProcessAllocationConstraint"/>
  <xsd:element ecore:ignore="true" name="ProcessPrototypeAllocationConstraint" type="am:ProcessPrototypeAllocationConstraint"/>
  <xsd:element ecore:ignore="true" name="RunnableAllocationConstraint" type="am:RunnableAllocationConstraint"/>
  <xsd:element ecore:ignore="true" name="AbstractElementMappingConstraint" type="am:AbstractElementMappingConstraint"/>
  <xsd:element ecore:ignore="true" name="Classification" type="am:Classification"/>
  <xsd:element ecore:ignore="true" name="CoreClassification" type="am:CoreClassification"/>
  <xsd:element ecore:ignore="true" name="MemoryClassification" type="am:MemoryClassification"/>
  <xsd:element ecore:ignore="true" name="StimuliModel" type="am:StimuliModel"/>
  <xsd:element ecore:ignore="true" name="Stimulus" type="am:Stimulus"/>
  <xsd:element ecore:ignore="true" name="ModeValueList" type="am:ModeValueList"/>
  <xsd:element ecore:ignore="true" name="ModeValueMapEntry" type="am:ModeValueMapEntry"/>
  <xsd:element ecore:ignore="true" name="ModeValue" type="am:ModeValue"/>
  <xsd:element ecore:ignore="true" name="ModeAssignment" type="am:ModeAssignment"/>
  <xsd:element ecore:ignore="true" name="ModeCondition" type="am:ModeCondition"/>
  <xsd:element ecore:ignore="true" name="ModeValueCondition" type="am:ModeValueCondition"/>
  <xsd:element ecore:ignore="true" name="ModeLabelCondition" type="am:ModeLabelCondition"/>
  <xsd:element ecore:ignore="true" name="ConditionDisjunction" type="am:ConditionDisjunction"/>
  <xsd:element ecore:ignore="true" name="ConditionDisjunctionEntry" type="am:ConditionDisjunctionEntry"/>
  <xsd:element ecore:ignore="true" name="ConditionConjunction" type="am:ConditionConjunction"/>
  <xsd:element ecore:ignore="true" name="Condition" type="am:Condition"/>
  <xsd:element ecore:ignore="true" name="ChannelFillCondition" type="am:ChannelFillCondition"/>
  <xsd:element ecore:ignore="true" name="FixedPeriodic" type="am:FixedPeriodic"/>
  <xsd:element ecore:ignore="true" name="PeriodicStimulus" type="am:PeriodicStimulus"/>
  <xsd:element ecore:ignore="true" name="RelativePeriodicStimulus" type="am:RelativePeriodicStimulus"/>
  <xsd:element ecore:ignore="true" name="VariableRateStimulus" type="am:VariableRateStimulus"/>
  <xsd:element ecore:ignore="true" name="Scenario" type="am:Scenario"/>
  <xsd:element ecore:ignore="true" name="PeriodicSyntheticStimulus" type="am:PeriodicSyntheticStimulus"/>
  <xsd:element ecore:ignore="true" name="CustomStimulus" type="am:CustomStimulus"/>
  <xsd:element ecore:ignore="true" name="SingleStimulus" type="am:SingleStimulus"/>
  <xsd:element ecore:ignore="true" name="InterProcessStimulus" type="am:InterProcessStimulus"/>
  <xsd:element ecore:ignore="true" name="PeriodicBurstStimulus" type="am:PeriodicBurstStimulus"/>
  <xsd:element ecore:ignore="true" name="EventStimulus" type="am:EventStimulus"/>
  <xsd:element ecore:ignore="true" name="ArrivalCurveStimulus" type="am:ArrivalCurveStimulus"/>
  <xsd:element ecore:ignore="true" name="ArrivalCurveEntry" type="am:ArrivalCurveEntry"/>
  <xsd:element ecore:ignore="true" name="Clock" type="am:Clock"/>
  <xsd:element ecore:ignore="true" name="ClockFunction" type="am:ClockFunction"/>
  <xsd:element ecore:ignore="true" name="ClockStepList" type="am:ClockStepList"/>
  <xsd:element ecore:ignore="true" name="ClockStep" type="am:ClockStep"/>
  <xsd:element ecore:ignore="true" name="SWModel" type="am:SWModel"/>
  <xsd:element ecore:ignore="true" name="AbstractMemoryElement" type="am:AbstractMemoryElement"/>
  <xsd:element ecore:ignore="true" name="AbstractProcess" type="am:AbstractProcess"/>
  <xsd:element ecore:ignore="true" name="CustomEntity" type="am:CustomEntity"/>
  <xsd:element ecore:ignore="true" name="ProcessChain" type="am:ProcessChain"/>
  <xsd:element ecore:ignore="true" name="IExecutable" type="am:IExecutable"/>
  <xsd:element ecore:ignore="true" name="Process" type="am:Process"/>
  <xsd:element ecore:ignore="true" name="IActivityGraphItemContainer" type="am:IActivityGraphItemContainer"/>
  <xsd:element ecore:ignore="true" name="ActivityGraph" type="am:ActivityGraph"/>
  <xsd:element ecore:ignore="true" name="ActivityGraphItem" type="am:ActivityGraphItem"/>
  <xsd:element ecore:ignore="true" name="Switch" type="am:Switch"/>
  <xsd:element ecore:ignore="true" name="SwitchEntry" type="am:SwitchEntry"/>
  <xsd:element ecore:ignore="true" name="SwitchDefault" type="am:SwitchDefault"/>
  <xsd:element ecore:ignore="true" name="ProbabilitySwitch" type="am:ProbabilitySwitch"/>
  <xsd:element ecore:ignore="true" name="ProbabilitySwitchEntry" type="am:ProbabilitySwitchEntry"/>
  <xsd:element ecore:ignore="true" name="WhileLoop" type="am:WhileLoop"/>
  <xsd:element ecore:ignore="true" name="Counter" type="am:Counter"/>
  <xsd:element ecore:ignore="true" name="WaitEvent" type="am:WaitEvent"/>
  <xsd:element ecore:ignore="true" name="SetEvent" type="am:SetEvent"/>
  <xsd:element ecore:ignore="true" name="ClearEvent" type="am:ClearEvent"/>
  <xsd:element ecore:ignore="true" name="EventMask" type="am:EventMask"/>
  <xsd:element ecore:ignore="true" name="OsEvent" type="am:OsEvent"/>
  <xsd:element ecore:ignore="true" name="InterProcessTrigger" type="am:InterProcessTrigger"/>
  <xsd:element ecore:ignore="true" name="EnforcedMigration" type="am:EnforcedMigration"/>
  <xsd:element ecore:ignore="true" name="SchedulePoint" type="am:SchedulePoint"/>
  <xsd:element ecore:ignore="true" name="TerminateProcess" type="am:TerminateProcess"/>
  <xsd:element ecore:ignore="true" name="Task" type="am:Task"/>
  <xsd:element ecore:ignore="true" name="ISR" type="am:ISR"/>
  <xsd:element ecore:ignore="true" name="ProcessPrototype" type="am:ProcessPrototype"/>
  <xsd:element ecore:ignore="true" name="ChainedProcessPrototype" type="am:ChainedProcessPrototype"/>
  <xsd:element ecore:ignore="true" name="GeneralPrecedence" type="am:GeneralPrecedence"/>
  <xsd:element ecore:ignore="true" name="AccessPrecedenceSpec" type="am:AccessPrecedenceSpec"/>
  <xsd:element ecore:ignore="true" name="OrderPrecedenceSpec" type="am:OrderPrecedenceSpec"/>
  <xsd:element ecore:ignore="true" name="IDependsOn" type="am:IDependsOn"/>
  <xsd:element ecore:ignore="true" name="DataDependency" type="am:DataDependency"/>
  <xsd:element ecore:ignore="true" name="RunnableParameter" type="am:RunnableParameter"/>
  <xsd:element ecore:ignore="true" name="Runnable" type="am:Runnable"/>
  <xsd:element ecore:ignore="true" name="Label" type="am:Label"/>
  <xsd:element ecore:ignore="true" name="Channel" type="am:Channel"/>
  <xsd:element ecore:ignore="true" name="ModeLabel" type="am:ModeLabel"/>
  <xsd:element ecore:ignore="true" name="Section" type="am:Section"/>
  <xsd:element ecore:ignore="true" name="ComputationItem" type="am:ComputationItem"/>
  <xsd:element ecore:ignore="true" name="ExecutionNeed" type="am:ExecutionNeed"/>
  <xsd:element ecore:ignore="true" name="NeedEntry" type="am:NeedEntry"/>
  <xsd:element ecore:ignore="true" name="Ticks" type="am:Ticks"/>
  <xsd:element ecore:ignore="true" name="TicksEntry" type="am:TicksEntry"/>
  <xsd:element ecore:ignore="true" name="ModeLabelAccess" type="am:ModeLabelAccess"/>
  <xsd:element ecore:ignore="true" name="LabelAccess" type="am:LabelAccess"/>
  <xsd:element ecore:ignore="true" name="ChannelAccess" type="am:ChannelAccess"/>
  <xsd:element ecore:ignore="true" name="ChannelSend" type="am:ChannelSend"/>
  <xsd:element ecore:ignore="true" name="ChannelReceive" type="am:ChannelReceive"/>
  <xsd:element ecore:ignore="true" name="SemaphoreAccess" type="am:SemaphoreAccess"/>
  <xsd:element ecore:ignore="true" name="SenderReceiverCommunication" type="am:SenderReceiverCommunication"/>
  <xsd:element ecore:ignore="true" name="SenderReceiverRead" type="am:SenderReceiverRead"/>
  <xsd:element ecore:ignore="true" name="SenderReceiverWrite" type="am:SenderReceiverWrite"/>
  <xsd:element ecore:ignore="true" name="ServerCall" type="am:ServerCall"/>
  <xsd:element ecore:ignore="true" name="SynchronousServerCall" type="am:SynchronousServerCall"/>
  <xsd:element ecore:ignore="true" name="AsynchronousServerCall" type="am:AsynchronousServerCall"/>
  <xsd:element ecore:ignore="true" name="GetResultServerCall" type="am:GetResultServerCall"/>
  <xsd:element ecore:ignore="true" name="Group" type="am:Group"/>
  <xsd:element ecore:ignore="true" name="CallArgument" type="am:CallArgument"/>
  <xsd:element ecore:ignore="true" name="RunnableCall" type="am:RunnableCall"/>
  <xsd:element ecore:ignore="true" name="CustomEventTrigger" type="am:CustomEventTrigger"/>
  <xsd:element ecore:ignore="true" name="DataType" type="am:DataType"/>
  <xsd:element ecore:ignore="true" name="CompoundType" type="am:CompoundType"/>
  <xsd:element ecore:ignore="true" name="Struct" type="am:Struct"/>
  <xsd:element ecore:ignore="true" name="StructEntry" type="am:StructEntry"/>
  <xsd:element ecore:ignore="true" name="Array" type="am:Array"/>
  <xsd:element ecore:ignore="true" name="Pointer" type="am:Pointer"/>
  <xsd:element ecore:ignore="true" name="TypeRef" type="am:TypeRef"/>
  <xsd:element ecore:ignore="true" name="Alias" type="am:Alias"/>
  <xsd:element ecore:ignore="true" name="TypeDefinition" type="am:TypeDefinition"/>
  <xsd:element ecore:ignore="true" name="DataTypeDefinition" type="am:DataTypeDefinition"/>
  <xsd:element ecore:ignore="true" name="BaseTypeDefinition" type="am:BaseTypeDefinition"/>
  <xsd:element ecore:ignore="true" name="Activation" type="am:Activation"/>
  <xsd:element ecore:ignore="true" name="PeriodicActivation" type="am:PeriodicActivation"/>
  <xsd:element ecore:ignore="true" name="VariableRateActivation" type="am:VariableRateActivation"/>
  <xsd:element ecore:ignore="true" name="SporadicActivation" type="am:SporadicActivation"/>
  <xsd:element ecore:ignore="true" name="SingleActivation" type="am:SingleActivation"/>
  <xsd:element ecore:ignore="true" name="EventActivation" type="am:EventActivation"/>
  <xsd:element ecore:ignore="true" name="CustomActivation" type="am:CustomActivation"/>
  <xsd:element ecore:ignore="true" name="LabelAccessStatistic" type="am:LabelAccessStatistic"/>
  <xsd:element ecore:ignore="true" name="RunEntityCallStatistic" type="am:RunEntityCallStatistic"/>
  <xsd:element ecore:ignore="true" name="LocalModeLabel" type="am:LocalModeLabel"/>
  <xsd:element ecore:ignore="true" name="LocalModeValue" type="am:LocalModeValue"/>
  <xsd:element ecore:ignore="true" name="LocalModeLabelAssignment" type="am:LocalModeLabelAssignment"/>
  <xsd:element ecore:ignore="true" name="LocalModeCondition" type="am:LocalModeCondition"/>
  <xsd:element ecore:ignore="true" name="ILocalModeValueSource" type="am:ILocalModeValueSource"/>
  <xsd:element ecore:ignore="true" name="ModeLiteralConst" type="am:ModeLiteralConst"/>
  <xsd:element ecore:ignore="true" name="IntegerConst" type="am:IntegerConst"/>
  <xsd:element ecore:ignore="true" name="ModeLabelRef" type="am:ModeLabelRef"/>
  <xsd:element ecore:ignore="true" name="LocalModeLabelRef" type="am:LocalModeLabelRef"/>
  <xsd:element ecore:ignore="true" name="ChannelFillRef" type="am:ChannelFillRef"/>
  <xsd:element ecore:ignore="true" name="ArithmeticExpression" type="am:ArithmeticExpression"/>
  <xsd:element ecore:ignore="true" name="ModeLabelAssignment" type="am:ModeLabelAssignment"/>
  <xsd:complexType name="Amalthea">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="commonElements" type="am:CommonElements"/>
          <xsd:element minOccurs="0" name="swModel" type="am:SWModel"/>
          <xsd:element minOccurs="0" name="hwModel" type="am:HWModel"/>
          <xsd:element minOccurs="0" name="osModel" type="am:OSModel"/>
          <xsd:element minOccurs="0" name="stimuliModel" type="am:StimuliModel"/>
          <xsd:element minOccurs="0" name="eventModel" type="am:EventModel"/>
          <xsd:element minOccurs="0" name="constraintsModel" type="am:ConstraintsModel"/>
          <xsd:element minOccurs="0" name="propertyConstraintsModel" type="am:PropertyConstraintsModel"/>
          <xsd:element minOccurs="0" name="mappingModel" type="am:MappingModel"/>
          <xsd:element minOccurs="0" name="componentsModel" type="am:ComponentsModel"/>
          <xsd:element minOccurs="0" name="configModel" type="am:ConfigModel"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:transient="true" ecore:volatile="true" name="version" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CommonElements">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tags" type="am:Tag"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="namespaces" type="am:Namespace"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="coreClassifiers" type="am:CoreClassifier"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="memoryClassifiers" type="am:MemoryClassifier"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="BaseObject">
    <xsd:annotation>
      <xsd:documentation>Base classes to be used to provide common functionality for all objects.
Needs to be extended by other classes.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IAnnotatable"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ReferableObject">
    <xsd:complexContent>
      <xsd:extension base="am:IReferable"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:IReferable" name="ReferableBaseObject">
    <xsd:complexContent>
      <xsd:extension base="am:IAnnotatable"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IAnnotatable">
    <xsd:annotation>
      <xsd:documentation>IAnnotatable: Possibility to store custom properties on elements</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="customProperties" type="am:CustomProperty"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ITaggable">
    <xsd:annotation>
      <xsd:documentation>ITaggable: Possibility to add tags to an elements</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute ecore:reference="am:Tag" name="tags">
      <xsd:simpleType>
        <xsd:list itemType="xsd:anyURI"/>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="INamed">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamedContainer" type="am:INamed" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt; _xifexpression = null;
&lt;%org.eclipse.emf.ecore.EObject%&gt; _eContainer = this.eContainer();
if ((_eContainer instanceof &lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt;))
{
	&lt;%org.eclipse.emf.ecore.EObject%&gt; _eContainer_1 = this.eContainer();
	_xifexpression = ((&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt;) _eContainer_1);
}
else
{
	_xifexpression = null;
}
return _xifexpression;</body>
        </operation>
        <operation name="getNamePrefix" type="ecore:EString" unique="false">
          <body>&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.Namespace%&gt; _namespace = this.getNamespace();
boolean _tripleEquals = (_namespace == null);
if (_tripleEquals)
{
	return "";
}
else
{
	_xifexpression = &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaExtensions%&gt;.toPlainString(this.getNamePrefixSegments(), this.getDefaultNameSeparator());
}
return _xifexpression;</body>
        </operation>
        <operation name="getQualifiedNameSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>final &lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; segments = this.getNamePrefixSegments();
&lt;%java.lang.String%&gt; _name = this.getName();
boolean _tripleNotEquals = (_name != null);
if (_tripleNotEquals)
{
	segments.add(this.getName());
}
return segments;</body>
        </operation>
        <operation name="getDefaultNameSeparator" type="ecore:EString" unique="false">
          <annotation source="http://www.eclipse.org/emf/2002/GenModel">
            <detail key="documentation">Overwrite this method to define a specific name separator.</detail>
          </annotation>
          <body>return ".";</body>
        </operation>
        <operation name="getNamespace" type="am:Namespace" unique="false">
          <body>return null;</body>
        </operation>
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <annotation source="http://www.eclipse.org/emf/2002/GenModel">
            <detail key="documentation">Overwrite this method to define a specific prefix (used by name-based references).</detail>
          </annotation>
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.Namespace%&gt; _namespace = this.getNamespace();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_namespace!=null)
{
	_qualifiedNameSegments=_namespace.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>INamed: Name attribute</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute default="" ecore:unsettable="false" name="name" type="ecore:EString"/>
    <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:transient="true" ecore:volatile="true" name="qualifiedName" type="ecore:EString"/>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IReferable">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getEncodedQualifiedName" type="ecore:EString" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaExtensions%&gt;.toEncodedString(this.getQualifiedNameSegments());</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>IReferable: Computed ID for name based references</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:INamed">
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:id="true" ecore:transient="true" ecore:volatile="true" name="uniqueName" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IDisplayName">
    <xsd:attribute name="displayName" type="ecore:EString"/>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IDescription">
    <xsd:attribute name="description" type="ecore:EString"/>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="INamespaceMember">
    <xsd:attribute ecore:reference="am:Namespace" name="namespace" type="xsd:anyURI"/>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="Tag">
    <xsd:annotation>
      <xsd:documentation>A tag for processes, runnables, events and labels</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute name="tagType" type="ecore:EString"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:ITaggable" ecore:transient="true" ecore:volatile="true" name="taggedObjects">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of objects (ITaggable) referring to this tag.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Namespace">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.Namespace%&gt; _previousSegment = this.getPreviousSegment();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_previousSegment!=null)
{
	_qualifiedNameSegments=_previousSegment.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableObject">
        <xsd:sequence>
          <xsd:element ecore:opposite="previousSegment" maxOccurs="unbounded" minOccurs="0" name="nextSegments" type="am:Namespace"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:opposite="nextSegments" ecore:reference="am:Namespace" name="previousSegment" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:INamespaceMember" ecore:transient="true" ecore:volatile="true" name="memberObjects">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of objects (INamespaceMember) referring to this namespace.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="RelationalOperator">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="EQUAL"/>
      <xsd:enumeration ecore:value="0" value="NOT_EQUAL"/>
      <xsd:enumeration ecore:value="0" value="LESS_THAN"/>
      <xsd:enumeration ecore:value="0" value="LESS_THAN_OR_EQUAL"/>
      <xsd:enumeration ecore:value="0" value="GREATER_THAN"/>
      <xsd:enumeration ecore:value="0" value="GREATER_THAN_OR_EQUAL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:implements="am:IDescription" name="Classifier">
    <xsd:annotation>
      <xsd:documentation>Classifiers for hardware properties</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CoreClassifier">
    <xsd:complexContent>
      <xsd:extension base="am:Classifier"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MemoryClassifier">
    <xsd:complexContent>
      <xsd:extension base="am:Classifier"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TransmissionPolicy">
    <xsd:annotation>
      <xsd:documentation>Data transmission details for communication (e.g. LabelAccesses)</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="chunkSize" type="am:DataSize"/>
    </xsd:sequence>
    <xsd:attribute default="0" ecore:unsettable="false" name="chunkProcessingTicks" type="ecore:EInt"/>
    <xsd:attribute default="1.0" ecore:unsettable="false" name="transmitRatio" type="ecore:EDouble"/>
  </xsd:complexType>
  <xsd:simpleType name="ParameterType">
    <xsd:annotation>
      <xsd:documentation>Parameter type (e.g. for scheduling parameters)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Integer"/>
      <xsd:enumeration ecore:value="0" value="Float"/>
      <xsd:enumeration ecore:value="0" value="Bool"/>
      <xsd:enumeration ecore:value="0" value="String"/>
      <xsd:enumeration ecore:value="0" value="Time"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" name="Quantity">
    <xsd:annotation>
      <xsd:documentation>Abstract class for Quantities (value + unit)</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:simpleType name="TimeUnit">
    <xsd:annotation>
      <xsd:documentation>Time units (enumeration of available units)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="s"/>
      <xsd:enumeration ecore:value="0" value="ms"/>
      <xsd:enumeration ecore:value="0" value="us"/>
      <xsd:enumeration ecore:value="0" value="ns"/>
      <xsd:enumeration ecore:value="0" value="ps"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:instanceClass="java.lang.Comparable{org.eclipse.app4mc.amalthea.model.Time}" ecore:interface="true" name="TimeComparable"/>
  <xsd:complexType ecore:implements="am:Value am:TimeComparable" name="Time">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%java.math.BigInteger%&gt; _value = this.getValue();
&lt;%java.lang.String%&gt; _plus = (_value + " ");
&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.TimeUnit%&gt; _unit = this.getUnit();
boolean _equals = &lt;%com.google.common.base.Objects%&gt;.equal(_unit, &lt;%org.eclipse.app4mc.amalthea.model.TimeUnit%&gt;._UNDEFINED_);
if (_equals)
{
	_xifexpression = "&lt;unit&gt;";
}
else
{
	_xifexpression = this.getUnit().getLiteral();
}
return (_plus + _xifexpression);</body>
        </operation>
        <operation name="compareTo" type="ecore:EInt" unique="false">
          <parameter name="t" type="am:Time" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.compareTimes(this, t);</body>
        </operation>
        <operation name="adjustUnit" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.adjustTimeUnit(this);</body>
        </operation>
        <operation name="add" type="am:Time" unique="false">
          <parameter name="t" type="am:Time" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.addTime(this, t);</body>
        </operation>
        <operation name="subtract" type="am:Time" unique="false">
          <parameter name="t" type="am:Time" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.subtractTime(this, t);</body>
        </operation>
        <operation name="multiply" type="am:Time" unique="false">
          <parameter name="v" type="ecore:ELong" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.multiply(this, v);</body>
        </operation>
        <operation name="multiply" type="am:Time" unique="false">
          <parameter name="v" type="ecore:EDouble" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.multiply(this, v);</body>
        </operation>
        <operation name="divide" type="ecore:EDouble" unique="false">
          <parameter name="t" type="am:Time" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.divideTime(this, t);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>General time class to define time value and unit.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Quantity">
        <xsd:attribute default="0" ecore:unsettable="false" name="value" type="ecore:EBigInteger"/>
        <xsd:attribute ecore:unsettable="false" name="unit" type="am:TimeUnit"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="FrequencyUnit">
    <xsd:annotation>
      <xsd:documentation>Frequency units (enumeration of available units)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Hz"/>
      <xsd:enumeration ecore:value="0" value="kHz"/>
      <xsd:enumeration ecore:value="0" value="MHz"/>
      <xsd:enumeration ecore:value="0" value="GHz"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="Frequency">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="toString" type="ecore:EString" unique="false">
          <body>double _value = this.getValue();
&lt;%java.lang.String%&gt; _plus = (&lt;%java.lang.Double%&gt;.valueOf(_value) + " ");
&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.FrequencyUnit%&gt; _unit = this.getUnit();
boolean _equals = &lt;%com.google.common.base.Objects%&gt;.equal(_unit, &lt;%org.eclipse.app4mc.amalthea.model.FrequencyUnit%&gt;._UNDEFINED_);
if (_equals)
{
	_xifexpression = "&lt;unit&gt;";
}
else
{
	_xifexpression = this.getUnit().getLiteral();
}
return (_plus + _xifexpression);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>General frequency class to define frequency value and unit</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Quantity">
        <xsd:attribute default="0.0" ecore:unsettable="false" name="value" type="am:NonNegativeDouble"/>
        <xsd:attribute ecore:unsettable="false" name="unit" type="am:FrequencyUnit"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="VoltageUnit">
    <xsd:annotation>
      <xsd:documentation>Voltage units (enumeration of available units)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="uV"/>
      <xsd:enumeration ecore:value="0" value="mV"/>
      <xsd:enumeration ecore:value="0" value="V"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="Voltage">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="toString" type="ecore:EString" unique="false">
          <body>double _value = this.getValue();
&lt;%java.lang.String%&gt; _plus = (&lt;%java.lang.Double%&gt;.valueOf(_value) + " ");
&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.VoltageUnit%&gt; _unit = this.getUnit();
boolean _equals = &lt;%com.google.common.base.Objects%&gt;.equal(_unit, &lt;%org.eclipse.app4mc.amalthea.model.VoltageUnit%&gt;._UNDEFINED_);
if (_equals)
{
	_xifexpression = "&lt;unit&gt;";
}
else
{
	_xifexpression = this.getUnit().getLiteral();
}
return (_plus + _xifexpression);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>General voltage class to define voltage value and unit</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Quantity">
        <xsd:attribute default="0.0" ecore:unsettable="false" name="value" type="ecore:EDouble"/>
        <xsd:attribute ecore:unsettable="false" name="unit" type="am:VoltageUnit"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="DataSizeUnit">
    <xsd:annotation>
      <xsd:documentation>Data size units (enumeration of available units)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="bit"/>
      <xsd:enumeration ecore:value="0" value="kbit"/>
      <xsd:enumeration ecore:value="0" value="Mbit"/>
      <xsd:enumeration ecore:value="0" value="Gbit"/>
      <xsd:enumeration ecore:value="0" value="Tbit"/>
      <xsd:enumeration ecore:value="0" value="Kibit"/>
      <xsd:enumeration ecore:value="0" value="Mibit"/>
      <xsd:enumeration ecore:value="0" value="Gibit"/>
      <xsd:enumeration ecore:value="0" value="Tibit"/>
      <xsd:enumeration ecore:value="0" value="B"/>
      <xsd:enumeration ecore:value="0" value="kB"/>
      <xsd:enumeration ecore:value="0" value="MB"/>
      <xsd:enumeration ecore:value="0" value="GB"/>
      <xsd:enumeration ecore:value="0" value="TB"/>
      <xsd:enumeration ecore:value="0" value="KiB"/>
      <xsd:enumeration ecore:value="0" value="MiB"/>
      <xsd:enumeration ecore:value="0" value="GiB"/>
      <xsd:enumeration ecore:value="0" value="TiB"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="DataSize">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%java.math.BigInteger%&gt; _value = this.getValue();
&lt;%java.lang.String%&gt; _plus = (_value + " ");
&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt; _unit = this.getUnit();
boolean _equals = &lt;%com.google.common.base.Objects%&gt;.equal(_unit, &lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt;._UNDEFINED_);
if (_equals)
{
	_xifexpression = "&lt;unit&gt;";
}
else
{
	_xifexpression = this.getUnit().getLiteral();
}
return (_plus + _xifexpression);</body>
        </operation>
        <operation name="getNumberBits" type="ecore:ELong" unique="false">
          <annotation source="http://www.eclipse.org/emf/2002/GenModel">
            <detail key="documentation">Convenience methods to retrieve the size in Bits and Bytes</detail>
          </annotation>
          <body>long _xblockexpression = (long) 0;
{
	&lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt; _unit = this.getUnit();
	boolean _tripleEquals = (_unit == &lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt;.BIT);
	if (_tripleEquals)
	{
		return this.getValue().longValue();
	}
	final &lt;%java.math.BigInteger%&gt; bits = &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.convertToBit(this);
	long _xifexpression = (long) 0;
	if ((bits == null))
	{
		_xifexpression = (-1L);
	}
	else
	{
		_xifexpression = bits.longValue();
	}
	_xblockexpression = _xifexpression;
}
return _xblockexpression;</body>
        </operation>
        <operation name="getNumberBytes" type="ecore:ELong" unique="false">
          <body>long _xblockexpression = (long) 0;
{
	&lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt; _unit = this.getUnit();
	boolean _tripleEquals = (_unit == &lt;%org.eclipse.app4mc.amalthea.model.DataSizeUnit%&gt;.B);
	if (_tripleEquals)
	{
		return this.getValue().longValue();
	}
	final &lt;%java.math.BigInteger%&gt; bits = &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.convertToBit(this);
	long _xifexpression = (long) 0;
	if ((bits == null))
	{
		_xifexpression = (-1L);
	}
	else
	{
		long _longValue = bits.longValue();
		long _divide = (_longValue / 8);
		_xifexpression = &lt;%java.lang.Double%&gt;.valueOf(&lt;%java.lang.Math%&gt;.ceil(_divide)).longValue();
	}
	_xblockexpression = _xifexpression;
}
return _xblockexpression;</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>General data size class to define size (value and unit)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Quantity">
        <xsd:attribute default="0" ecore:unsettable="false" name="value" type="ecore:EBigInteger"/>
        <xsd:attribute ecore:unsettable="false" name="unit" type="am:DataSizeUnit"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="DataRateUnit">
    <xsd:annotation>
      <xsd:documentation>Data rate units (enumeration of available units)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="bitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="kbitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="MbitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="GbitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="TbitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="KibitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="MibitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="GibitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="TibitPerSecond"/>
      <xsd:enumeration ecore:value="0" value="BPerSecond"/>
      <xsd:enumeration ecore:value="0" value="kBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="MBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="GBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="TBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="KiBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="MiBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="GiBPerSecond"/>
      <xsd:enumeration ecore:value="0" value="TiBPerSecond"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:instanceClass="java.lang.Comparable{org.eclipse.app4mc.amalthea.model.DataRate}" ecore:interface="true" name="DataRateComparable"/>
  <xsd:complexType ecore:implements="am:DataRateComparable" name="DataRate">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%java.math.BigInteger%&gt; _value = this.getValue();
&lt;%java.lang.String%&gt; _plus = (_value + " ");
&lt;%java.lang.String%&gt; _xifexpression = null;
&lt;%org.eclipse.app4mc.amalthea.model.DataRateUnit%&gt; _unit = this.getUnit();
boolean _equals = &lt;%com.google.common.base.Objects%&gt;.equal(_unit, &lt;%org.eclipse.app4mc.amalthea.model.DataRateUnit%&gt;._UNDEFINED_);
if (_equals)
{
	_xifexpression = "&lt;unit&gt;";
}
else
{
	_xifexpression = this.getUnit().getLiteral().replace("PerSecond", "/s");
}
return (_plus + _xifexpression);</body>
        </operation>
        <operation name="compareTo" type="ecore:EInt" unique="false">
          <parameter name="rate" type="am:DataRate" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices%&gt;.compareDataRates(this, rate);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>General data rate class to define rate (value and unit)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Quantity">
        <xsd:attribute default="0" ecore:unsettable="false" name="value" type="ecore:EBigInteger"/>
        <xsd:attribute ecore:unsettable="false" name="unit" type="am:DataRateUnit"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="CustomProperty">
    <xsd:annotation>
      <xsd:documentation>custom property container for map</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="value" type="am:Value"/>
    </xsd:sequence>
    <xsd:attribute name="key" type="ecore:EString" use="required"/>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="Value">
    <xsd:annotation>
      <xsd:documentation>Abstract generalization of a value entry.</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType name="ListObject">
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="values" type="am:Value"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MapObject">
    <xsd:annotation>
      <xsd:documentation>@since 1.2</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="entries" type="am:CustomProperty"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StringObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype String as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute name="value" type="ecore:EString" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BigIntegerObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype BigInteger as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="0" ecore:unsettable="false" name="value" type="ecore:EBigInteger" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ReferenceObject">
    <xsd:annotation>
      <xsd:documentation>Object for using object reference as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:reference="am:IReferable" name="value" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IntegerObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype integer as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="0" ecore:unsettable="false" name="value" type="ecore:EInt" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LongObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype long as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="0" ecore:unsettable="false" name="value" type="ecore:ELong" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FloatObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype float as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="value" type="ecore:EFloat" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DoubleObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype double as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="value" type="ecore:EDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BooleanObject">
    <xsd:annotation>
      <xsd:documentation>Object for using the elementary datatype boolean as generic parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Value">
        <xsd:attribute ecore:default="false" ecore:unsettable="false" name="value" type="ecore:EBoolean" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="NumericStatistic"/>
  <xsd:complexType name="MinAvgMaxStatistic">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Statistic to provide capabilities for min, max and avg</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:NumericStatistic">
        <xsd:attribute default="0" ecore:unsettable="false" name="min" type="ecore:EInt"/>
        <xsd:attribute default="0f" ecore:unsettable="false" name="avg" type="ecore:EFloat"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="max" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SingleValueStatistic">
    <xsd:complexContent>
      <xsd:extension base="am:NumericStatistic">
        <xsd:attribute default="0f" ecore:unsettable="false" name="value" type="ecore:EFloat"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="SamplingType">
    <xsd:annotation>
      <xsd:documentation>The types of sampling</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="default"/>
      <xsd:enumeration ecore:value="0" value="BestCase"/>
      <xsd:enumeration ecore:value="0" value="WorstCase"/>
      <xsd:enumeration ecore:value="0" value="AverageCase"/>
      <xsd:enumeration ecore:value="0" value="CornerCase"/>
      <xsd:enumeration ecore:value="0" value="Uniform"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ITimeDeviation">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="am:Time" unique="false"/>
        <operation name="getUpperBound" type="am:Time" unique="false"/>
        <operation name="getAverage" type="am:Time" unique="false"/>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TimeInterval">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage(this.getLowerBound(), this.getUpperBound());</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="lowerBound" type="am:Time"/>
      <xsd:element name="upperBound" type="am:Time"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="TimeConstant">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="am:Time" unique="false">
          <body>return this.getValue();</body>
        </operation>
        <operation name="getUpperBound" type="am:Time" unique="false">
          <body>return this.getValue();</body>
        </operation>
        <operation name="getAverage" type="am:Time" unique="false">
          <body>return this.getValue();</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ITimeDeviation">
        <xsd:sequence>
          <xsd:element name="value" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeHistogram">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getLowerBound_Time(this.getEntries());</body>
        </operation>
        <operation name="getUpperBound" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getUpperBound_Time(this.getEntries());</body>
        </operation>
        <operation name="getAverage" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage_Time(this.getEntries());</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ITimeDeviation">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:TimeHistogramEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeHistogramEntry">
    <xsd:complexContent>
      <xsd:extension base="am:TimeInterval">
        <xsd:attribute ecore:default="1" ecore:unsettable="false" name="occurrences" type="am:PositiveLong" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITimeDeviation" name="BoundedTimeDistribution">
    <xsd:complexContent>
      <xsd:extension base="am:TimeInterval"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TruncatedTimeDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ITimeDeviation">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="lowerBound" type="am:Time"/>
          <xsd:element minOccurs="0" name="upperBound" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeBoundaries">
    <xsd:annotation>
      <xsd:documentation>Defines the upper and lower bounds of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedTimeDistribution">
        <xsd:attribute ecore:unsettable="false" name="samplingType" type="am:SamplingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeStatistics">
    <xsd:annotation>
      <xsd:documentation>Defines the upper bound, lower bound and mean of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedTimeDistribution">
        <xsd:sequence>
          <xsd:element name="average" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeUniformDistribution">
    <xsd:annotation>
      <xsd:documentation>Uniform distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedTimeDistribution"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeGaussDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfTruncatedNormalDistribution(this.getLowerBound(), this.getUpperBound(), this.getMean(), this.getSd());</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Gauss distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TruncatedTimeDistribution">
        <xsd:sequence>
          <xsd:element name="mean" type="am:Time"/>
          <xsd:element name="sd" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeWeibullEstimatorsDistribution">
    <xsd:annotation>
      <xsd:documentation>Weibull Distribution
The parameter of a Weibull distribution (kappa, lambda...) are calculated from the estimators minimum, maximum and average.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedTimeDistribution">
        <xsd:sequence>
          <xsd:element name="average" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="pRemainPromille" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeBetaDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="am:Time" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfBetaDistribution(this.getLowerBound(), this.getUpperBound(), &lt;%java.lang.Double%&gt;.valueOf(this.getAlpha()), &lt;%java.lang.Double%&gt;.valueOf(this.getBeta()));</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Beta distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedTimeDistribution">
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="alpha" type="am:PositiveDouble" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="beta" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IDiscreteValueDeviation">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:ELongObject" unique="false"/>
        <operation name="getUpperBound" type="ecore:ELongObject" unique="false"/>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false"/>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="DiscreteValueInterval">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage(this.getLowerBound(), this.getUpperBound());</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute ecore:default="0" ecore:unsettable="false" name="lowerBound" type="ecore:ELongObject" use="required"/>
    <xsd:attribute ecore:default="0" ecore:unsettable="false" name="upperBound" type="ecore:ELongObject" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueConstant">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:ELongObject" unique="false">
          <body>return &lt;%java.lang.Long%&gt;.valueOf(this.getValue());</body>
        </operation>
        <operation name="getUpperBound" type="ecore:ELongObject" unique="false">
          <body>return &lt;%java.lang.Long%&gt;.valueOf(this.getValue());</body>
        </operation>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%java.lang.Double%&gt;.valueOf(&lt;%java.lang.Long%&gt;.valueOf(this.getValue()).doubleValue());</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IDiscreteValueDeviation">
        <xsd:attribute ecore:default="0" ecore:unsettable="false" name="value" type="ecore:ELong" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueHistogram">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:ELongObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getLowerBound_DV(this.getEntries());</body>
        </operation>
        <operation name="getUpperBound" type="ecore:ELongObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getUpperBound_DV(this.getEntries());</body>
        </operation>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage_DV(this.getEntries());</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IDiscreteValueDeviation">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:DiscreteValueHistogramEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueHistogramEntry">
    <xsd:complexContent>
      <xsd:extension base="am:DiscreteValueInterval">
        <xsd:attribute ecore:default="1" ecore:unsettable="false" name="occurrences" type="am:PositiveLong" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:IDiscreteValueDeviation" name="BoundedDiscreteValueDistribution">
    <xsd:complexContent>
      <xsd:extension base="am:DiscreteValueInterval"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TruncatedDiscreteValueDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IDiscreteValueDeviation">
        <xsd:attribute name="lowerBound" type="ecore:ELongObject"/>
        <xsd:attribute name="upperBound" type="ecore:ELongObject"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueBoundaries">
    <xsd:annotation>
      <xsd:documentation>Defines the upper and lower bounds of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedDiscreteValueDistribution">
        <xsd:attribute ecore:unsettable="false" name="samplingType" type="am:SamplingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueStatistics">
    <xsd:annotation>
      <xsd:documentation>Defines the upper bound, lower bound and mean of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedDiscreteValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="average" type="ecore:EDoubleObject" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueUniformDistribution">
    <xsd:annotation>
      <xsd:documentation>Uniform distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedDiscreteValueDistribution"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueGaussDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfTruncatedNormalDistribution(this.getLowerBound(), this.getUpperBound(), &lt;%java.lang.Double%&gt;.valueOf(this.getMean()), &lt;%java.lang.Double%&gt;.valueOf(this.getSd()));</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Gauss distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TruncatedDiscreteValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="mean" type="ecore:EDouble" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="sd" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueWeibullEstimatorsDistribution">
    <xsd:annotation>
      <xsd:documentation>Weibull Distribution
The parameter of a Weibull distribution (kappa, lambda...) are calculated from the estimators minimum, maximum and average.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedDiscreteValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="average" type="ecore:EDoubleObject" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="pRemainPromille" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DiscreteValueBetaDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfBetaDistribution(this.getLowerBound(), this.getUpperBound(), &lt;%java.lang.Double%&gt;.valueOf(this.getAlpha()), &lt;%java.lang.Double%&gt;.valueOf(this.getBeta()));</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Beta distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedDiscreteValueDistribution">
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="alpha" type="am:PositiveDouble" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="beta" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IContinuousValueDeviation">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:EDoubleObject" unique="false"/>
        <operation name="getUpperBound" type="ecore:EDoubleObject" unique="false"/>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false"/>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ContinuousValueInterval">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage(this.getLowerBound(), this.getUpperBound());</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="lowerBound" type="ecore:EDoubleObject" use="required"/>
    <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="upperBound" type="ecore:EDoubleObject" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueConstant">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%java.lang.Double%&gt;.valueOf(this.getValue());</body>
        </operation>
        <operation name="getUpperBound" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%java.lang.Double%&gt;.valueOf(this.getValue());</body>
        </operation>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%java.lang.Double%&gt;.valueOf(this.getValue());</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IContinuousValueDeviation">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="value" type="ecore:EDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueHistogram">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLowerBound" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getLowerBound_CV(this.getEntries());</body>
        </operation>
        <operation name="getUpperBound" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getUpperBound_CV(this.getEntries());</body>
        </operation>
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverage_CV(this.getEntries());</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IContinuousValueDeviation">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:ContinuousValueHistogramEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueHistogramEntry">
    <xsd:complexContent>
      <xsd:extension base="am:ContinuousValueInterval">
        <xsd:attribute ecore:default="1" ecore:unsettable="false" name="occurrences" type="am:PositiveLong" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:IContinuousValueDeviation" name="BoundedContinuousValueDistribution">
    <xsd:complexContent>
      <xsd:extension base="am:ContinuousValueInterval"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TruncatedContinuousValueDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IContinuousValueDeviation">
        <xsd:attribute name="lowerBound" type="ecore:EDoubleObject"/>
        <xsd:attribute name="upperBound" type="ecore:EDoubleObject"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueBoundaries">
    <xsd:annotation>
      <xsd:documentation>Defines the upper and lower bounds of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedContinuousValueDistribution">
        <xsd:attribute ecore:unsettable="false" name="samplingType" type="am:SamplingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueStatistics">
    <xsd:annotation>
      <xsd:documentation>Defines the upper bound, lower bound and mean of a value interval without defining the distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedContinuousValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="average" type="ecore:EDoubleObject" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueUniformDistribution">
    <xsd:annotation>
      <xsd:documentation>Uniform distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedContinuousValueDistribution"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueGaussDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfTruncatedNormalDistribution(this.getLowerBound(), this.getUpperBound(), &lt;%java.lang.Double%&gt;.valueOf(this.getMean()), &lt;%java.lang.Double%&gt;.valueOf(this.getSd()));</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Gauss distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TruncatedContinuousValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="mean" type="ecore:EDouble" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="sd" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueWeibullEstimatorsDistribution">
    <xsd:annotation>
      <xsd:documentation>Weibull Distribution
The parameter of a Weibull distribution (kappa, lambda...) are calculated from the estimators minimum, maximum and average.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedContinuousValueDistribution">
        <xsd:attribute ecore:default="0.0" ecore:unsettable="false" name="average" type="ecore:EDoubleObject" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="pRemainPromille" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ContinuousValueBetaDistribution">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getAverage" type="ecore:EDoubleObject" unique="false">
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaServices2%&gt;.getAverageOfBetaDistribution(this.getLowerBound(), this.getUpperBound(), &lt;%java.lang.Double%&gt;.valueOf(this.getAlpha()), &lt;%java.lang.Double%&gt;.valueOf(this.getBeta()));</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Beta distribution</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BoundedContinuousValueDistribution">
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="alpha" type="am:PositiveDouble" use="required"/>
        <xsd:attribute ecore:default="1.0" ecore:unsettable="false" name="beta" type="am:PositiveDouble" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="Mode">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NumericMode">
    <xsd:complexContent>
      <xsd:extension base="am:Mode"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EnumMode">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getLiteral" type="am:ModeLiteral" unique="false">
          <parameter name="literal" type="ecore:EString" unique="false"/>
          <body>final &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt; _function = new &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt;()
{
	public &lt;%java.lang.Boolean%&gt; apply(final &lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; it)
	{
		&lt;%java.lang.String%&gt; _name = it.getName();
		return &lt;%java.lang.Boolean%&gt;.valueOf(&lt;%com.google.common.base.Objects%&gt;.equal(_name, literal));
	}
};
return &lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;&gt;findFirst(this.getLiterals(), _function);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Mode">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingMode" maxOccurs="unbounded" minOccurs="0" name="literals" type="am:ModeLiteral"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ModeLiteral">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt; _containingMode = this.getContainingMode();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingMode!=null)
{
	_qualifiedNameSegments=_containingMode.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%java.lang.String%&gt; _xifexpression = null;
boolean _isNullOrEmpty = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(this.getName());
if (_isNullOrEmpty)
{
	_xifexpression = "&lt;literal&gt;";
}
else
{
	_xifexpression = this.getName();
}
return _xifexpression;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="literals" ecore:reference="am:EnumMode" name="containingMode" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType ecore:instanceClass="long" name="Address">
    <xsd:annotation>
      <xsd:documentation>Hardware Address (long; specified as hexadecimal value)</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:minInclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="int" name="PositiveInt">
    <xsd:restriction base="xsd:string">
      <xsd:minExclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="long" name="PositiveLong">
    <xsd:restriction base="xsd:string">
      <xsd:minExclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="double" name="PositiveDouble">
    <xsd:restriction base="xsd:string">
      <xsd:minExclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="int" name="NonNegativeInt">
    <xsd:restriction base="xsd:string">
      <xsd:minInclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="long" name="NonNegativeLong">
    <xsd:restriction base="xsd:string">
      <xsd:minInclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType ecore:instanceClass="double" name="NonNegativeDouble">
    <xsd:restriction base="xsd:string">
      <xsd:minInclusive value="0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType ecore:implements="am:IComponentContainer am:IInterfaceContainer" name="ComponentsModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="structures" type="am:ComponentStructure"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="systems" type="am:System"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IComponentContainer">
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="components" type="am:Component"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IInterfaceContainer">
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="interfaces" type="am:MainInterface"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ISystem">
    <xsd:sequence>
      <xsd:element ecore:opposite="containingSystem" maxOccurs="unbounded" minOccurs="0" name="componentInstances" type="am:ComponentInstance"/>
      <xsd:element ecore:opposite="containingSystem" maxOccurs="unbounded" minOccurs="0" name="connectors" type="am:Connector"/>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="groundedPorts" type="am:QualifiedPort"/>
    </xsd:sequence>
    <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:QualifiedPort" ecore:transient="true" ecore:volatile="true" name="innerPorts">
      <xsd:simpleType>
        <xsd:list itemType="xsd:anyURI"/>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="ComponentInterface">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingInterface" maxOccurs="unbounded" minOccurs="0" name="subInterfaces" type="am:SubInterface"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:TypeDefinition" name="dataType" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamespaceMember am:IComponentStructureMember" name="MainInterface">
    <xsd:complexContent>
      <xsd:extension base="am:ComponentInterface">
        <xsd:attribute default="1.0" ecore:unsettable="false" name="version" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SubInterface">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.ComponentInterface%&gt; _containingInterface = this.getContainingInterface();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingInterface!=null)
{
	_qualifiedNameSegments=_containingInterface.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ComponentInterface">
        <xsd:attribute ecore:changeable="false" ecore:opposite="subInterfaces" ecore:reference="am:ComponentInterface" name="containingInterface" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="ComponentPort">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.Component%&gt; _containingComponent = this.getContainingComponent();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingComponent!=null)
{
	_qualifiedNameSegments=_containingComponent.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="ports" ecore:reference="am:Component" name="containingComponent" type="xsd:anyURI"/>
        <xsd:attribute ecore:unsettable="false" name="kind" type="am:InterfaceKind"/>
        <xsd:attribute ecore:reference="am:ComponentInterface" name="interface" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ComponentStructure">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getContainingStructure" type="am:ComponentStructure" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.ComponentStructure%&gt; _xifexpression = null;
&lt;%org.eclipse.emf.ecore.EObject%&gt; _eContainer = this.eContainer();
if ((_eContainer instanceof &lt;%org.eclipse.app4mc.amalthea.model.ComponentStructure%&gt;))
{
	&lt;%org.eclipse.emf.ecore.EObject%&gt; _eContainer_1 = this.eContainer();
	_xifexpression = ((&lt;%org.eclipse.app4mc.amalthea.model.ComponentStructure%&gt;) _eContainer_1);
}
else
{
	_xifexpression = null;
}
return _xifexpression;</body>
        </operation>
        <operation name="getDefaultNameSeparator" type="ecore:EString" unique="false">
          <body>return "::";</body>
        </operation>
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.ComponentStructure%&gt; _containingStructure = this.getContainingStructure();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingStructure!=null)
{
	_qualifiedNameSegments=_containingStructure.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="subStructures" type="am:ComponentStructure"/>
        </xsd:sequence>
        <xsd:attribute default="" ecore:unsettable="false" name="structureType" type="ecore:EString"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:IComponentStructureMember" ecore:transient="true" ecore:volatile="true" name="memberObjects">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of objects (IComponentStructureMember) referring to this structure.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IComponentStructureMember">
    <xsd:attribute ecore:reference="am:ComponentStructure" name="structure" type="xsd:anyURI"/>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable am:INamespaceMember am:IComponentStructureMember" name="Component">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingComponent" maxOccurs="unbounded" minOccurs="0" name="ports" type="am:ComponentPort"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:AbstractProcess" name="processes">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Runnable" name="runnables">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Label" name="labels">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Semaphore" name="semaphores">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:OsEvent" name="osEvents">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ISystem" name="Composite">
    <xsd:complexContent>
      <xsd:extension base="am:Component"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable am:ISystem" name="System">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="ComponentInstance">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt; _namedContainer = this.getNamedContainer();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_namedContainer!=null)
{
	_qualifiedNameSegments=_namedContainer.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:opposite="componentInstances" ecore:reference="am:ISystem" name="containingSystem" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Component" name="type" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed am:ITaggable" name="Connector">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="sourcePort" type="am:QualifiedPort"/>
          <xsd:element minOccurs="0" name="targetPort" type="am:QualifiedPort"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="implementedInterfaces" type="am:InterfaceChannel"/>
        </xsd:sequence>
        <xsd:attribute ecore:opposite="connectors" ecore:reference="am:ISystem" name="containingSystem" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="InterfaceChannel">
    <xsd:attribute ecore:reference="am:ComponentInterface" name="key" type="xsd:anyURI" use="required"/>
    <xsd:attribute ecore:reference="am:Channel" name="value" type="xsd:anyURI"/>
  </xsd:complexType>
  <xsd:complexType name="QualifiedPort">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:ComponentInstance" name="instance" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:ComponentPort" name="port" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="InterfaceKind">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="provides"/>
      <xsd:enumeration ecore:value="0" value="requires"/>
      <xsd:enumeration ecore:value="0" value="provides_requires"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ConfigModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="eventsToTrace" type="am:EventConfig"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed" name="EventConfig">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:EntityEvent" name="event" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ConstraintsModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="eventChains" type="am:EventChain"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="timingConstraints" type="am:TimingConstraint"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="affinityConstraints" type="am:AffinityConstraint"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="runnableSequencingConstraints" type="am:RunnableSequencingConstraint"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="dataAgeConstraints" type="am:DataAgeConstraint"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="requirements" type="am:Requirement"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="dataCoherencyGroups" type="am:DataCoherencyGroup"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="dataStabilityGroups" type="am:DataStabilityGroup"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="physicalSectionConstraints" type="am:PhysicalSectionConstraint"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="RunnableOrderType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="successor"/>
      <xsd:enumeration ecore:value="0" value="immediateSuccessorStartSequence"/>
      <xsd:enumeration ecore:value="0" value="immediateSuccessorAnySequence"/>
      <xsd:enumeration ecore:value="0" value="immediateSuccessorEndSequence"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="RunnableSequencingConstraint">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="2" name="runnableGroups" type="am:RunnableEntityGroup"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="orderType" type="am:RunnableOrderType"/>
        <xsd:attribute ecore:reference="am:AbstractProcess" name="processScope">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="AffinityConstraint">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="SeparationConstraint">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all separation constraints</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AffinityConstraint"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="PairingConstraint">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all pairing constraints</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AffinityConstraint"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ProcessConstraint">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all process related constraint
The target describes the entity on which the processes can be mapped</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="target" type="am:ProcessConstraintTarget"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="RunnableConstraint">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all runnable related constraint
The target describes the entity on which the runnables can be mapped</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="target" type="am:RunnableConstraintTarget"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="DataConstraint">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all data related constraint
The target describes the entity on which the data can be mapped</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="target" type="am:DataConstraintTarget"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:RunnableConstraint am:BaseObject" name="RunnableSeparationConstraint">
    <xsd:annotation>
      <xsd:documentation>A runnable-separation-constraint
groups describes the runnable-groups that should be separated from each other on the target
if there is only one group then this means that the runnables of this group are not allowed to be executed on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SeparationConstraint">
        <xsd:sequence>
          <xsd:element maxOccurs="2" name="groups" type="am:RunnableGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ProcessConstraint am:BaseObject" name="ProcessSeparationConstraint">
    <xsd:annotation>
      <xsd:documentation>A process-separation-constraint
groups describes the process-groups that should be separated from each other on the target
if there is only one group then this means that the processes of this group are not allowed to be executed on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SeparationConstraint">
        <xsd:sequence>
          <xsd:element maxOccurs="2" name="groups" type="am:ProcessGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:DataConstraint am:BaseObject" name="DataSeparationConstraint">
    <xsd:annotation>
      <xsd:documentation>A data-separation-constraint
groups describes the label-groups that should be separated from each other on the target
if there is only one group then this means that the label of this group is not allowed to be executed on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SeparationConstraint">
        <xsd:sequence>
          <xsd:element maxOccurs="2" name="groups" type="am:LabelEntityGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:RunnableConstraint am:BaseObject" name="RunnablePairingConstraint">
    <xsd:annotation>
      <xsd:documentation>A runnable-pairing-constraint
runnables describes the group of runnables that should be paired on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:PairingConstraint">
        <xsd:sequence>
          <xsd:element name="group" type="am:RunnableGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ProcessConstraint am:BaseObject" name="ProcessPairingConstraint">
    <xsd:annotation>
      <xsd:documentation>A process-pairing-constraint
processes describes the group of processes that should be paired on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:PairingConstraint">
        <xsd:sequence>
          <xsd:element name="group" type="am:ProcessGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:DataConstraint am:BaseObject" name="DataPairingConstraint">
    <xsd:annotation>
      <xsd:documentation>A data-pairing-constraint
labels describes the group of labels that should be paired on the target</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:PairingConstraint">
        <xsd:sequence>
          <xsd:element name="group" type="am:LabelGroup"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="RunnableConstraintTarget">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all possible targets for runnable-constraints</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ProcessConstraintTarget">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all possible targets for process-constraints</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="DataConstraintTarget">
    <xsd:annotation>
      <xsd:documentation>An abstract superclass for all possible targets for data-constraints</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:BaseObject" name="TargetMemory">
    <xsd:annotation>
      <xsd:documentation>A memory target description
A memory can be a target for data-constraints
memories: the reference to zero or more Memories. If this list is empty, the target stands for all memories!</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:DataConstraintTarget">
        <xsd:attribute ecore:reference="am:Memory" name="memories">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ProcessConstraintTarget am:BaseObject" name="TargetCore">
    <xsd:annotation>
      <xsd:documentation>A core target description
A core can be a target for runnable-constraints, process-constraints and scheduler-constraints
cores: the reference to zero or more Cores. If this list is empty, the target stands for all cores!</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:RunnableConstraintTarget">
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="cores">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ProcessConstraintTarget am:BaseObject" name="TargetScheduler">
    <xsd:annotation>
      <xsd:documentation>A scheduler target description
A scheduler can be a target for runnable-constraints and process-constraints
schedulers: the reference to zero or more Schedulers. If this list is empty, the target stands for all schedulers!</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:RunnableConstraintTarget">
        <xsd:attribute ecore:reference="am:Scheduler" name="schedulers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="LabelGroup">
    <xsd:annotation>
      <xsd:documentation>An abstract description for a group of labels that can be paired or separated by a runnable-constraint</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="RunnableGroup">
    <xsd:annotation>
      <xsd:documentation>An abstract description for a group of runnables that can be paired or separated by a runnable-constraint</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ProcessGroup">
    <xsd:annotation>
      <xsd:documentation>An abstract description for a group of processes that can be paired or separated by a process-constraint</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:BaseObject" name="LabelEntityGroup">
    <xsd:annotation>
      <xsd:documentation>A group of labels that can be paired or separated by a data-constraint</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:LabelGroup">
        <xsd:attribute ecore:reference="am:Label" name="labels" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:BaseObject" name="RunnableEntityGroup">
    <xsd:annotation>
      <xsd:documentation>A group of runnables that can be paired or separated by a runnable-constraint</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:RunnableGroup">
        <xsd:attribute ecore:reference="am:Runnable" name="runnables" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:BaseObject" name="ProcessEntityGroup">
    <xsd:annotation>
      <xsd:documentation>A group of processes that can be paired or separated by a process-constraint</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ProcessGroup">
        <xsd:attribute ecore:reference="am:Process" name="processes" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ProcessGroup am:BaseObject" name="TagGroup">
    <xsd:annotation>
      <xsd:documentation>A group that contains only a tag and groups all objects that are marked with this tag
This can be runnables or processes</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:RunnableGroup">
        <xsd:attribute ecore:reference="am:Tag" name="tag" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:INamed" name="AbstractEventChain">
    <xsd:annotation>
      <xsd:documentation>Describes an event chain which must have a minimum of two events (stimulus and response)
If there are more events the event chain have to be divided into segments. Each segment is another event chain.
Alternative event paths are contained in strands.
stimulus: Beginning of chain
response: End of chain
segments: Sub event chains
strands: alternative event paths</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="items" type="am:EventChainItem"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Event" name="stimulus" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:Event" name="response" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="itemType" type="am:EventChainItemType"/>
        <xsd:attribute default="1" ecore:unsettable="false" name="minItemsCompleted" type="am:PositiveInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="EventChainItemType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="sequence"/>
      <xsd:enumeration ecore:value="0" value="parallel"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType ecore:implements="am:IReferable" name="EventChain">
    <xsd:complexContent>
      <xsd:extension base="am:AbstractEventChain"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SubEventChain">
    <xsd:complexContent>
      <xsd:extension base="am:AbstractEventChain"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="EventChainItem">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getEventChain" type="am:AbstractEventChain" unique="false"/>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:EventChainItem" name="EventChainReference">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:EventChain" name="eventChain" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:EventChainItem" name="EventChainContainer">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element name="eventChain" type="am:SubEventChain"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TimingConstraint">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PhysicalSectionConstraint">
    <xsd:annotation>
      <xsd:documentation>This constraint is used to limit a section in Memories</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:reference="am:Section" name="section" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:Memory" name="memories" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="SynchronizationConstraint">
    <xsd:annotation>
      <xsd:documentation>Base class for synchronization constraints, which limit the distance between events
multipleOccurrencesAllowed: Defines whether multiple event occurrences are allowed for analysis
tolerance: Maximum allowed tolerance</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TimingConstraint">
        <xsd:sequence>
          <xsd:element name="tolerance" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute default="false" ecore:unsettable="false" name="multipleOccurrencesAllowed" type="ecore:EBoolean"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventSynchronizationConstraint">
    <xsd:annotation>
      <xsd:documentation>The synchronization constraint considers a group of events and limits the distance of the events within this group.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SynchronizationConstraint">
        <xsd:attribute ecore:reference="am:EntityEvent" name="events" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="SynchronizationType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Stimulus"/>
      <xsd:enumeration ecore:value="0" value="Response"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="EventChainSynchronizationConstraint">
    <xsd:annotation>
      <xsd:documentation>A synchronization constraint describes the allowed tolerance in synchronization between two event chains
scope: Considered event chains that have to by in sync
type: Defines which parts of the event chains have to be in sync</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SynchronizationConstraint">
        <xsd:attribute ecore:reference="am:EventChain" name="scope" use="required">
          <xsd:simpleType>
            <xsd:restriction>
              <xsd:simpleType>
                <xsd:list itemType="xsd:anyURI"/>
              </xsd:simpleType>
              <xsd:length value="2"/>
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="type" type="am:SynchronizationType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="MappingType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="OneToOne"/>
      <xsd:enumeration ecore:value="0" value="Reaction"/>
      <xsd:enumeration ecore:value="0" value="UniqueReaction"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="DelayConstraint">
    <xsd:annotation>
      <xsd:documentation>This constraint describes how a source and a target event are placed relative to each other</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TimingConstraint">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="upper" type="am:Time"/>
          <xsd:element minOccurs="0" name="lower" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="mappingType" type="am:MappingType"/>
        <xsd:attribute ecore:reference="am:EntityEvent" name="source" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:EntityEvent" name="target" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="LatencyType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Age"/>
      <xsd:enumeration ecore:value="0" value="Reaction"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="EventChainLatencyConstraint">
    <xsd:annotation>
      <xsd:documentation>A latency constraint describes the allowed range in latency between a stimulus and its response.
scope: Considered event chain that defines the stimulus and response relation
type: Defines the point of view (forward or backward)
minimum: Minimum allowed latency
maximum: Maximum allowed latency</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TimingConstraint">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="minimum" type="am:Time"/>
          <xsd:element minOccurs="0" name="maximum" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:EventChain" name="scope" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="type" type="am:LatencyType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RepetitionConstraint">
    <xsd:annotation>
      <xsd:documentation>A repetition constraint prescribes the distribution of a single event during runtime.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TimingConstraint">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="lower" type="am:Time"/>
          <xsd:element minOccurs="0" name="upper" type="am:Time"/>
          <xsd:element minOccurs="0" name="jitter" type="am:Time"/>
          <xsd:element minOccurs="0" name="period" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:EntityEvent" name="event" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="span" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DataAgeConstraint">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element name="dataAge" type="am:DataAge"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:Label" name="label" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="DataAge"/>
  <xsd:complexType name="DataAgeCycle">
    <xsd:complexContent>
      <xsd:extension base="am:DataAge">
        <xsd:attribute default="0" ecore:unsettable="false" name="minimumCycle" type="ecore:EInt"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="maximumCycle" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DataAgeTime">
    <xsd:complexContent>
      <xsd:extension base="am:DataAge">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="minimumTime" type="am:Time"/>
          <xsd:element minOccurs="0" name="maximumTime" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:INamed" name="Requirement">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element name="limit" type="am:RequirementLimit"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="severity" type="am:Severity"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessRequirement">
    <xsd:complexContent>
      <xsd:extension base="am:Requirement">
        <xsd:attribute ecore:reference="am:AbstractProcess" name="process" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunnableRequirement">
    <xsd:complexContent>
      <xsd:extension base="am:Requirement">
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ArchitectureRequirement">
    <xsd:complexContent>
      <xsd:extension base="am:Requirement">
        <xsd:attribute ecore:reference="am:Component" name="component" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessChainRequirement">
    <xsd:complexContent>
      <xsd:extension base="am:Requirement">
        <xsd:attribute ecore:reference="am:ProcessChain" name="processChain" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="RequirementLimit">
    <xsd:attribute ecore:unsettable="false" name="limitType" type="am:LimitType"/>
  </xsd:complexType>
  <xsd:complexType name="CPUPercentageRequirementLimit">
    <xsd:complexContent>
      <xsd:extension base="am:RequirementLimit">
        <xsd:attribute ecore:unsettable="false" name="metric" type="am:CPUPercentageMetric"/>
        <xsd:attribute default="0.0" ecore:unsettable="false" name="limitValue" type="ecore:EDouble"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="hardwareContext" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FrequencyRequirementLimit">
    <xsd:complexContent>
      <xsd:extension base="am:RequirementLimit">
        <xsd:sequence>
          <xsd:element name="limitValue" type="am:Frequency"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="metric" type="am:FrequencyMetric"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PercentageRequirementLimit">
    <xsd:complexContent>
      <xsd:extension base="am:RequirementLimit">
        <xsd:attribute ecore:unsettable="false" name="metric" type="am:PercentageMetric"/>
        <xsd:attribute default="0.0" ecore:unsettable="false" name="limitValue" type="ecore:EDouble"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CountRequirementLimit">
    <xsd:complexContent>
      <xsd:extension base="am:RequirementLimit">
        <xsd:attribute ecore:unsettable="false" name="metric" type="am:CountMetric"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="limitValue" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TimeRequirementLimit">
    <xsd:complexContent>
      <xsd:extension base="am:RequirementLimit">
        <xsd:sequence>
          <xsd:element name="limitValue" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="metric" type="am:TimeMetric"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="Severity">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Cosmetic"/>
      <xsd:enumeration ecore:value="0" value="Minor"/>
      <xsd:enumeration ecore:value="0" value="Major"/>
      <xsd:enumeration ecore:value="0" value="Critical"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LimitType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="UpperLimit"/>
      <xsd:enumeration ecore:value="0" value="LowerLimit"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TimeMetric">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="ActivateToActivate"/>
      <xsd:enumeration ecore:value="0" value="CoreExecutionTime"/>
      <xsd:enumeration ecore:value="0" value="EndToEnd"/>
      <xsd:enumeration ecore:value="0" value="EndToStart"/>
      <xsd:enumeration ecore:value="0" value="GrossExecutionTime"/>
      <xsd:enumeration ecore:value="0" value="Lateness"/>
      <xsd:enumeration ecore:value="0" value="MemoryAccessTime"/>
      <xsd:enumeration ecore:value="0" value="NetExecutionTime"/>
      <xsd:enumeration ecore:value="0" value="OsOverhead"/>
      <xsd:enumeration ecore:value="0" value="ParkingTime"/>
      <xsd:enumeration ecore:value="0" value="PollingTime"/>
      <xsd:enumeration ecore:value="0" value="ReadyTime"/>
      <xsd:enumeration ecore:value="0" value="ResponseTime"/>
      <xsd:enumeration ecore:value="0" value="RunningTime"/>
      <xsd:enumeration ecore:value="0" value="StartDelay"/>
      <xsd:enumeration ecore:value="0" value="StartToStart"/>
      <xsd:enumeration ecore:value="0" value="WaitingTime"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CountMetric">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="Activations"/>
      <xsd:enumeration ecore:value="0" value="BoundedMigrations"/>
      <xsd:enumeration ecore:value="0" value="CacheHit"/>
      <xsd:enumeration ecore:value="0" value="CacheMiss"/>
      <xsd:enumeration ecore:value="0" value="FullMigrations"/>
      <xsd:enumeration ecore:value="0" value="MtaLimitExceeding"/>
      <xsd:enumeration ecore:value="0" value="Preemptions"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PercentageMetric">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="CacheHitRatio"/>
      <xsd:enumeration ecore:value="0" value="CacheMissRatio"/>
      <xsd:enumeration ecore:value="0" value="CoreExecutionTimeRelative"/>
      <xsd:enumeration ecore:value="0" value="MemoryAccessTimeRelative"/>
      <xsd:enumeration ecore:value="0" value="NormalizedLateness"/>
      <xsd:enumeration ecore:value="0" value="NormalizedResponseTime"/>
      <xsd:enumeration ecore:value="0" value="OsOverheadRelative"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CPUPercentageMetric">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="CPUBuffering"/>
      <xsd:enumeration ecore:value="0" value="CPULoad"/>
      <xsd:enumeration ecore:value="0" value="CPUParking"/>
      <xsd:enumeration ecore:value="0" value="CPUPolling"/>
      <xsd:enumeration ecore:value="0" value="CPUReady"/>
      <xsd:enumeration ecore:value="0" value="CPURunning"/>
      <xsd:enumeration ecore:value="0" value="CPUWaiting"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="FrequencyMetric">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="CacheHitFrequency"/>
      <xsd:enumeration ecore:value="0" value="CacheMissFrequency"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="DataCoherencyGroup">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="scope" type="am:DataGroupScope"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Label" name="labels" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="direction" type="am:CoherencyDirection"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="CoherencyDirection">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="input"/>
      <xsd:enumeration ecore:value="0" value="output"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="DataStabilityGroup">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="scope" type="am:DataGroupScope"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Label" name="labels" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="DataGroupScope"/>
  <xsd:complexType name="ProcessScope">
    <xsd:complexContent>
      <xsd:extension base="am:DataGroupScope">
        <xsd:attribute ecore:reference="am:AbstractProcess" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunnableScope">
    <xsd:complexContent>
      <xsd:extension base="am:DataGroupScope">
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ComponentScope">
    <xsd:complexContent>
      <xsd:extension base="am:DataGroupScope">
        <xsd:attribute ecore:reference="am:Component" name="component" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="events" type="am:Event"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable am:IDescription" name="Event">
    <xsd:annotation>
      <xsd:documentation>An abstract event</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventSet">
    <xsd:annotation>
      <xsd:documentation>A set of entity-events</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Event">
        <xsd:attribute ecore:reference="am:EntityEvent" name="events" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="EntityEvent">
    <xsd:annotation>
      <xsd:documentation>An abstract event that describes the notification of a changed state of an entity</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Event"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="TriggerEvent">
    <xsd:annotation>
      <xsd:documentation>Defines Events to be used in Stimuli as trigger.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CustomEvent">
    <xsd:complexContent>
      <xsd:extension base="am:TriggerEvent">
        <xsd:attribute name="eventType" type="ecore:EString"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:CustomEventTrigger" ecore:transient="true" ecore:volatile="true" name="explicitTriggers">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of triggers (CustomEventTrigger).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StimulusEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a stimulus.
It contains only the stimulus but no event type because a stimulus has only one event type.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent">
        <xsd:attribute ecore:reference="am:Stimulus" name="entity" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a process
eventType: The type of the Event
entity: The process that fires the event (optional)
processingUnit: The processing unit that executes the process when the event is fired (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:ProcessEventType"/>
        <xsd:attribute ecore:reference="am:Process" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="processingUnit" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessChainEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of some process within a process chain
eventType: The type of the Event
entity: The process that fires the event (optional)
processingUnit: The processing unit that executes the process when the event is fired (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:ProcessEventType"/>
        <xsd:attribute ecore:reference="am:ProcessChain" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="processingUnit" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunnableEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a runnable
eventType: The type of event
entity: The runnable that fires the event (optional)
process: The process that executes the runnable (optional)
processingUnit: The processing unit that executes the runnable (executes the process that calls the runnable) (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TriggerEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:RunnableEventType"/>
        <xsd:attribute ecore:reference="am:Runnable" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="processingUnit" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LabelEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a label access
eventType: The type of event
entity: The accessed label that fires the event (optional)
runnable: The runnable that accesses the label (optional)
process: The process that accesses the label (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TriggerEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:LabelEventType"/>
        <xsd:attribute ecore:reference="am:Label" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ModeLabelEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a mode label access
eventType: The type of event
entity: The accessed mode label that fires the event
runnable: The runnable that accesses the mode label (optional)
process: The process that accesses the mode label (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TriggerEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:ModeLabelEventType"/>
        <xsd:attribute ecore:reference="am:ModeLabel" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ChannelEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a channel access
eventType: The type of event
entity: The accessed channel that fires the event (optional)
runnable: The runnable that accesses the label (optional)
process: The process that accesses the label (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TriggerEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:ChannelEventType"/>
        <xsd:attribute ecore:reference="am:Channel" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SemaphoreEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a semaphore access
eventType: The type of event
entity: The accessed semaphore that fires the event (optional)
runnable: The runnable that accesses the semaphore (optional)
process: The process that accesses the semaphore (optional)
processingUnit: The processing unit that executes the process/runnable that accesses the semaphore (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:SemaphoreEventType"/>
        <xsd:attribute ecore:reference="am:Semaphore" name="entity" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="processingUnit" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ComponentEvent">
    <xsd:annotation>
      <xsd:documentation>Describes the event of a component
eventType: The type of event
entity: The component that fires the event (optional)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:EntityEvent">
        <xsd:attribute ecore:unsettable="false" name="eventType" type="am:ComponentEventType"/>
        <xsd:attribute ecore:reference="am:Component" name="entity" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ProcessEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a process event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="activate"/>
      <xsd:enumeration ecore:value="0" value="start"/>
      <xsd:enumeration ecore:value="0" value="resume"/>
      <xsd:enumeration ecore:value="0" value="preempt"/>
      <xsd:enumeration ecore:value="0" value="poll"/>
      <xsd:enumeration ecore:value="0" value="run"/>
      <xsd:enumeration ecore:value="0" value="wait"/>
      <xsd:enumeration ecore:value="0" value="poll_parking"/>
      <xsd:enumeration ecore:value="0" value="park"/>
      <xsd:enumeration ecore:value="0" value="release_parking"/>
      <xsd:enumeration ecore:value="0" value="release"/>
      <xsd:enumeration ecore:value="0" value="terminate"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="RunnableEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a runnable event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="start"/>
      <xsd:enumeration ecore:value="0" value="suspend"/>
      <xsd:enumeration ecore:value="0" value="resume"/>
      <xsd:enumeration ecore:value="0" value="terminate"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LabelEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a label event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="read"/>
      <xsd:enumeration ecore:value="0" value="write"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ModeLabelEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a mode label event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="read"/>
      <xsd:enumeration ecore:value="0" value="write"/>
      <xsd:enumeration ecore:value="0" value="increment"/>
      <xsd:enumeration ecore:value="0" value="decrement"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ChannelEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a label event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="send"/>
      <xsd:enumeration ecore:value="0" value="receive"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SemaphoreEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a semaphore event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="lock"/>
      <xsd:enumeration ecore:value="0" value="unlock"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ComponentEventType">
    <xsd:annotation>
      <xsd:documentation>The types of a component event</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_all_"/>
      <xsd:enumeration ecore:value="0" value="start"/>
      <xsd:enumeration ecore:value="0" value="end"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="HWModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="definitions" type="am:HwDefinition"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="featureCategories" type="am:HwFeatureCategory"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="structures" type="am:HwStructure"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="domains" type="am:HwDomain"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="HwStructure">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="ports" type="am:HwPort"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="structures" type="am:HwStructure"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="modules" type="am:HwModule"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="connections" type="am:HwConnection"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="structureType" type="am:StructureType"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:HwPort" ecore:transient="true" ecore:volatile="true" name="innerPorts">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="HwModule">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="ports" type="am:HwPort"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:PowerDomain" name="powerDomain" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:FrequencyDomain" name="frequencyDomain" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="HwDomain">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FrequencyDomain">
    <xsd:complexContent>
      <xsd:extension base="am:HwDomain">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="defaultValue" type="am:Frequency"/>
        </xsd:sequence>
        <xsd:attribute default="false" ecore:unsettable="false" name="clockGating" type="ecore:EBoolean"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PowerDomain">
    <xsd:complexContent>
      <xsd:extension base="am:HwDomain">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="defaultValue" type="am:Voltage"/>
        </xsd:sequence>
        <xsd:attribute default="false" ecore:unsettable="false" name="powerGating" type="ecore:EBoolean"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:HwDestination am:HwPathElement" name="ProcessingUnit">
    <xsd:complexContent>
      <xsd:extension base="am:HwModule">
        <xsd:sequence>
          <xsd:element ecore:opposite="source" maxOccurs="unbounded" minOccurs="0" name="accessElements" type="am:HwAccessElement"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="caches" type="am:Cache"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:ProcessingUnitDefinition" name="definition" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:HwDestination" name="Memory">
    <xsd:complexContent>
      <xsd:extension base="am:HwModule">
        <xsd:attribute ecore:reference="am:MemoryDefinition" name="definition" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:MemoryMapping" ecore:transient="true" ecore:volatile="true" name="mappings">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of mappings (MemoryMapping).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="MemoryType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="DRAM"/>
      <xsd:enumeration ecore:value="0" value="SRAM"/>
      <xsd:enumeration ecore:value="0" value="FLASH"/>
      <xsd:enumeration ecore:value="0" value="PCM"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType ecore:implements="am:HwPathElement" name="Cache">
    <xsd:complexContent>
      <xsd:extension base="am:HwModule">
        <xsd:attribute ecore:reference="am:CacheDefinition" name="definition" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="HwFeatureCategory">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingCategory" maxOccurs="unbounded" minOccurs="0" name="features" type="am:HwFeature"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="featureType" type="am:HwFeatureType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HwFeature">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.HwFeatureCategory%&gt; _containingCategory = this.getContainingCategory();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingCategory!=null)
{
	_qualifiedNameSegments=_containingCategory.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.HwFeatureCategory%&gt; _containingCategory = this.getContainingCategory();
&lt;%java.lang.String%&gt; _name = null;
if (_containingCategory!=null)
{
	_name=_containingCategory.getName();
}
final &lt;%java.lang.String%&gt; featureName = _name;
&lt;%java.lang.String%&gt; _xifexpression = null;
boolean _isNullOrEmpty = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(featureName);
if (_isNullOrEmpty)
{
	_xifexpression = "&lt;category&gt;";
}
else
{
	_xifexpression = featureName;
}
&lt;%java.lang.String%&gt; _plus = (_xifexpression + "::");
&lt;%java.lang.String%&gt; _xifexpression_1 = null;
boolean _isNullOrEmpty_1 = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(this.getName());
if (_isNullOrEmpty_1)
{
	_xifexpression_1 = "&lt;feature&gt;";
}
else
{
	_xifexpression_1 = this.getName();
}
return (_plus + _xifexpression_1);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="features" ecore:reference="am:HwFeatureCategory" name="containingCategory" type="xsd:anyURI"/>
        <xsd:attribute default="0.0" ecore:unsettable="false" name="value" type="ecore:EDouble"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="HwPort">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt; _namedContainer = this.getNamedContainer();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_namedContainer!=null)
{
	_qualifiedNameSegments=_namedContainer.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute default="0" ecore:unsettable="false" name="bitWidth" type="ecore:EInt"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="priority" type="ecore:EInt"/>
        <xsd:attribute ecore:unsettable="false" name="portType" type="am:PortType"/>
        <xsd:attribute ecore:unsettable="false" name="portInterface" type="am:PortInterface"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:transient="true" ecore:unsettable="false" ecore:volatile="true" name="delegated" type="ecore:EBoolean"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:HwConnection" ecore:transient="true" ecore:volatile="true" name="connections">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of connections (HwConnection).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:HwPathElement" name="ConnectionHandler">
    <xsd:complexContent>
      <xsd:extension base="am:HwModule">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="internalConnections" type="am:HwConnection"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:ConnectionHandlerDefinition" name="definition" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:HwPathElement am:ITaggable" name="HwConnection">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt; _namedContainer = this.getNamedContainer();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_namedContainer!=null)
{
	_qualifiedNameSegments=_namedContainer.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
        <operation name="getPorts" type="am:HwPort" unique="false" upperBound="-1">
          <body>return &lt;%org.eclipse.emf.common.util.ECollections%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.HwPort%&gt;&gt;unmodifiableEList(&lt;%org.eclipse.emf.common.util.ECollections%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.HwPort%&gt;&gt;toEList(&lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.HwPort%&gt;&gt;filterNull(&lt;%org.eclipse.xtext.xbase.lib.CollectionLiterals%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.HwPort%&gt;&gt;newArrayList(this.getPort1(), this.getPort2()))));</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="readLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Read latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="writeLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Write latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="dataRate" type="am:DataRate"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:HwPort" name="port1" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:HwPort" name="port2" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:transient="true" ecore:unsettable="false" ecore:volatile="true" name="internal" type="ecore:EBoolean"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed" name="HwAccessElement">
    <xsd:complexContent>
      <xsd:extension base="am:ITaggable">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingAccessElement" minOccurs="0" name="accessPath" type="am:HwAccessPath"/>
          <xsd:element minOccurs="0" name="readLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Read latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="writeLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Write latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="dataRate" type="am:DataRate"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:opposite="accessElements" ecore:reference="am:ProcessingUnit" name="source" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:HwDestination" name="destination" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StructureType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="System"/>
      <xsd:enumeration ecore:value="0" value="ECU"/>
      <xsd:enumeration ecore:value="0" value="Microcontroller"/>
      <xsd:enumeration ecore:value="0" value="SoC"/>
      <xsd:enumeration ecore:value="0" value="Cluster"/>
      <xsd:enumeration ecore:value="0" value="Group"/>
      <xsd:enumeration ecore:value="0" value="Array"/>
      <xsd:enumeration ecore:value="0" value="Area"/>
      <xsd:enumeration ecore:value="0" value="Region"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CacheType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="instruction"/>
      <xsd:enumeration ecore:value="0" value="data"/>
      <xsd:enumeration ecore:value="0" value="unified"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PortType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="initiator"/>
      <xsd:enumeration ecore:value="0" value="responder"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SchedPolicy">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="RoundRobin"/>
      <xsd:enumeration ecore:value="0" value="FCFS"/>
      <xsd:enumeration ecore:value="0" value="PriorityBased"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="WriteStrategy">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="none"/>
      <xsd:enumeration ecore:value="0" value="writeback"/>
      <xsd:enumeration ecore:value="0" value="writethrough"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="HwDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessingUnitDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:HwDefinition">
        <xsd:attribute ecore:unsettable="false" name="puType" type="am:PuType"/>
        <xsd:attribute ecore:reference="am:HwFeature" name="features">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:CoreClassifier" name="classifiers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ConnectionHandlerDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:HwDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="readLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Read latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="writeLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Write latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="dataRate" type="am:DataRate"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="policy" type="am:SchedPolicy"/>
        <xsd:attribute default="1" ecore:unsettable="false" name="maxBurstSize" type="am:PositiveInt"/>
        <xsd:attribute default="1" ecore:unsettable="false" name="maxConcurrentTransfers" type="am:PositiveInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MemoryDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:HwDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="size" type="am:DataSize"/>
          <xsd:element minOccurs="0" name="accessLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Access latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="dataRate" type="am:DataRate"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="memoryType" type="am:MemoryType"/>
        <xsd:attribute ecore:reference="am:MemoryClassifier" name="classifiers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CacheDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:HwDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="size" type="am:DataSize"/>
          <xsd:element minOccurs="0" name="lineSize" type="am:DataSize"/>
          <xsd:element minOccurs="0" name="accessLatency" type="am:IDiscreteValueDeviation">
            <xsd:annotation>
              <xsd:documentation>
                <p>
                  <b>Access latency [cycles]</b>
                </p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="cacheType" type="am:CacheType"/>
        <xsd:attribute ecore:unsettable="false" name="writeStrategy" type="am:WriteStrategy"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="nWays" type="ecore:EInt"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="coherency" type="ecore:EBoolean"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="exclusive" type="ecore:EBoolean"/>
        <xsd:attribute default="0.0" ecore:unsettable="false" name="hitRate" type="ecore:EDouble"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="HwPath">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getContainingAccessElement" type="am:HwAccessElement" unique="false">
          <body>return null;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:ProcessingUnit" ecore:transient="true" ecore:volatile="true" name="source" type="xsd:anyURI"/>
    <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:HwDestination" ecore:transient="true" ecore:volatile="true" name="destination" type="xsd:anyURI"/>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed" name="HwAccessPath">
    <xsd:complexContent>
      <xsd:extension base="am:HwPath">
        <xsd:attribute ecore:changeable="false" ecore:opposite="accessPath" ecore:reference="am:HwAccessElement" name="containingAccessElement" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:HwPathElement" name="pathElements" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute default="0" ecore:unsettable="false" name="startAddress" type="am:Address"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="endAddress" type="am:Address"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="memOffset" type="am:Address"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="HwPathElement">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getPorts" type="am:HwPort" unique="false" upperBound="-1"/>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IReferable"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="HwDestination">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getPorts" type="am:HwPort" unique="false" upperBound="-1"/>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:IReferable"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="PuType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="GPU"/>
      <xsd:enumeration ecore:value="0" value="CPU"/>
      <xsd:enumeration ecore:value="0" value="Accelerator"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PortInterface">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="custom"/>
      <xsd:enumeration ecore:value="0" value="CAN"/>
      <xsd:enumeration ecore:value="0" value="Flexray"/>
      <xsd:enumeration ecore:value="0" value="LIN"/>
      <xsd:enumeration ecore:value="0" value="MOST"/>
      <xsd:enumeration ecore:value="0" value="Ethernet"/>
      <xsd:enumeration ecore:value="0" value="SPI"/>
      <xsd:enumeration ecore:value="0" value="I2C"/>
      <xsd:enumeration ecore:value="0" value="AXI"/>
      <xsd:enumeration ecore:value="0" value="AHB"/>
      <xsd:enumeration ecore:value="0" value="APB"/>
      <xsd:enumeration ecore:value="0" value="SWR"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="HwFeatureType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="performance"/>
      <xsd:enumeration ecore:value="0" value="power"/>
      <xsd:enumeration ecore:value="0" value="performance_and_power"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="MappingModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="schedulerAllocation" type="am:SchedulerAllocation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="runnableAllocation" type="am:RunnableAllocation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="taskAllocation" type="am:TaskAllocation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="isrAllocation" type="am:ISRAllocation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="memoryMapping" type="am:MemoryMapping"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="physicalSectionMapping" type="am:PhysicalSectionMapping"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="addressMappingType" type="am:MemoryAddressMappingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="MemoryAddressMappingType">
    <xsd:annotation>
      <xsd:documentation>Defines how to interpret the memory addresses in this mapping model</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="none"/>
      <xsd:enumeration ecore:value="0" value="address"/>
      <xsd:enumeration ecore:value="0" value="offset"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="SchedulerAllocation">
    <xsd:annotation>
      <xsd:documentation>Allocation of Schedulers</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Scheduler" name="scheduler" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="responsibility" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="executingPU" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ISchedulingParameterContainer" name="TaskAllocation">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Task" name="task" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:TaskScheduler" name="scheduler" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:ProcessingUnit" name="affinity">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ISRAllocation">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:ISR" name="isr" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:InterruptController" name="controller" type="xsd:anyURI" use="required"/>
        <xsd:attribute name="priority" type="ecore:EIntegerObject"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunnableAllocation">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Scheduler" name="scheduler" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:Runnable" name="entity" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MemoryMapping">
    <xsd:annotation>
      <xsd:documentation>Mapping of AbstractMemoryElement (Label, Runnable, ISR, Task, ...)
to a specific memory.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:AbstractMemoryElement" name="abstractElement" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:Memory" name="memory" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="memoryPositionAddress" type="am:Address">
          <xsd:annotation>
            <xsd:documentation>The position of the element in the mapped memory</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PhysicalSectionMapping">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:reference="am:Section" name="origin" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Memory" name="memory" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="startAddress" type="am:Address"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="endAddress" type="am:Address"/>
        <xsd:attribute ecore:reference="am:Label" name="labels">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Runnable" name="runEntities">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="OSModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="semaphores" type="am:Semaphore"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="operatingSystems" type="am:OperatingSystem"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="osOverheads" type="am:OsOverhead"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="schedulerDefinitions" type="am:SchedulerDefinition"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="schedulingParameterDefinitions" type="am:SchedulingParameterDefinition"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="OsDataConsistency">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="dataStability" type="am:DataStability"/>
          <xsd:element minOccurs="0" name="nonAtomicDataCoherency" type="am:NonAtomicDataCoherency"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="mode" type="am:OsDataConsistencyMode"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DataStability">
    <xsd:attribute default="false" ecore:unsettable="false" name="enabled" type="ecore:EBoolean"/>
    <xsd:attribute name="algorithm" type="ecore:EString"/>
    <xsd:attribute ecore:unsettable="false" name="accessMultiplicity" type="am:AccessMultiplicity"/>
    <xsd:attribute ecore:unsettable="false" name="level" type="am:DataStabilityLevel"/>
  </xsd:complexType>
  <xsd:complexType name="NonAtomicDataCoherency">
    <xsd:attribute default="false" ecore:unsettable="false" name="enabled" type="ecore:EBoolean"/>
    <xsd:attribute name="algorithm" type="ecore:EString"/>
    <xsd:attribute ecore:unsettable="false" name="accessMultiplicity" type="am:AccessMultiplicity"/>
  </xsd:complexType>
  <xsd:simpleType name="OsDataConsistencyMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="noProtection"/>
      <xsd:enumeration ecore:value="0" value="automaticProtection"/>
      <xsd:enumeration ecore:value="0" value="customProtection"/>
      <xsd:enumeration ecore:value="0" value="handledByModelElements"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="AccessMultiplicity">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="singleAccess"/>
      <xsd:enumeration ecore:value="0" value="multipleAccesses"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DataStabilityLevel">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="period"/>
      <xsd:enumeration ecore:value="0" value="process"/>
      <xsd:enumeration ecore:value="0" value="scheduleSection"/>
      <xsd:enumeration ecore:value="0" value="runnable"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="Semaphore">
    <xsd:annotation>
      <xsd:documentation>name: Name of semaphore
maxValue: maximum number of users which can access the semaphore simultaneously
initialValue: number of users which access semaphore at system startup
priorityCeilingProtocol: enables priority ceiling for this resource</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:unsettable="false" name="semaphoreType" type="am:SemaphoreType"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="initialValue" type="am:NonNegativeInt"/>
        <xsd:attribute default="1" ecore:unsettable="false" name="maxValue" type="am:PositiveInt"/>
        <xsd:attribute default="true" ecore:unsettable="false" name="ownership" type="ecore:EBoolean"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="priorityCeilingProtocol" type="ecore:EBoolean"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:SemaphoreAccess" ecore:transient="true" ecore:volatile="true" name="semaphoreAccesses">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of accesses (SemaphoreAccess).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Component" ecore:transient="true" ecore:volatile="true" name="referringComponents">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of components the semaphore belongs to.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="SemaphoreType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="CountingSemaphore"/>
      <xsd:enumeration ecore:value="0" value="Resource"/>
      <xsd:enumeration ecore:value="0" value="Spinlock"/>
      <xsd:enumeration ecore:value="0" value="Mutex"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:implements="am:ISchedulingParameterContainer" name="Scheduler">
    <xsd:annotation>
      <xsd:documentation>
        Scheduler

        <ul>
          
          <li>definition: determines algorithm for scheduling and its required parameters</li>
          
          <li>schedulingParameters: current values for global scheduling parameters</li>
          
          <li>computation items: steps to perform the scheduling algorithm</li>
          
        </ul>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="computationItems" type="am:ComputationItem"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:SchedulerDefinition" name="definition" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:SchedulerAllocation" ecore:transient="true" ecore:volatile="true" name="schedulerAllocations">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of scheduler allocations (SchedulerAllocation).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:RunnableAllocation" ecore:transient="true" ecore:volatile="true" name="runnableAllocations">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of runnable allocations (RunnableAllocation).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TaskScheduler">
    <xsd:complexContent>
      <xsd:extension base="am:Scheduler">
        <xsd:sequence>
          <xsd:element ecore:opposite="child" minOccurs="0" name="parentAssociation" type="am:SchedulerAssociation"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:SchedulerAssociation" ecore:transient="true" ecore:volatile="true" name="childAssociations">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of child associations (SchedulerAssociation).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:TaskAllocation" ecore:transient="true" ecore:volatile="true" name="taskAllocations">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of task allocations (TaskAllocation).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:TaskScheduler" ecore:transient="true" ecore:volatile="true" name="parentScheduler" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:TaskScheduler" ecore:transient="true" ecore:volatile="true" name="childSchedulers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SchedulerAssociation">
    <xsd:complexContent>
      <xsd:extension base="am:ISchedulingParameterContainer">
        <xsd:attribute ecore:changeable="false" ecore:opposite="parentAssociation" ecore:reference="am:TaskScheduler" name="child" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:TaskScheduler" name="parent" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="InterruptController">
    <xsd:complexContent>
      <xsd:extension base="am:Scheduler">
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:ISRAllocation" ecore:transient="true" ecore:volatile="true" name="isrAllocations">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of ISR allocations (ISRAllocation).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="OsDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="SchedulerDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:OsDefinition">
        <xsd:attribute ecore:reference="am:SchedulingParameterDefinition" name="algorithmParameters">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:SchedulingParameterDefinition" name="processParameters">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute default="false" ecore:unsettable="false" name="requiresParentScheduler" type="ecore:EBoolean"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="passesParametersUpwards" type="ecore:EBoolean"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="hasExactlyOneChild" type="ecore:EBoolean"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SchedulingParameterDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:OsDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="defaultValue" type="am:Value"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="type" type="am:ParameterType"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="many" type="ecore:EBoolean"/>
        <xsd:attribute default="true" ecore:unsettable="false" name="mandatory" type="ecore:EBoolean"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:SchedulerDefinition" ecore:transient="true" ecore:volatile="true" name="schedulerDefinitions">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of scheduler definitions from which this parameter definition is used.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ISchedulingParameterContainer">
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="schedulingParameters" type="am:SchedulingParameter"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="SchedulingParameter">
    <xsd:sequence>
      <xsd:element name="value" type="am:Value"/>
    </xsd:sequence>
    <xsd:attribute ecore:reference="am:SchedulingParameterDefinition" name="key" type="xsd:anyURI" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="OsOverhead">
    <xsd:complexContent>
      <xsd:extension base="am:OsDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="apiOverhead" type="am:OsAPIOverhead"/>
          <xsd:element minOccurs="0" name="isrCategory1Overhead" type="am:OsISROverhead"/>
          <xsd:element minOccurs="0" name="isrCategory2Overhead" type="am:OsISROverhead"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="OsAPIOverhead">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="apiSendMessage" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiTerminateTask" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSchedule" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiRequestResource" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiReleaseResource" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSetEvent" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiWaitEvent" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiClearEvent" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiActivateTask" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiEnforcedMigration" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSuspendOsInterrupts" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiResumeOsInterrupts" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiRequestSpinlock" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiReleaseSpinlock" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSenderReceiverRead" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSenderReceiverWrite" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiSynchronousServerCallPoint" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiIocRead" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="apiIocWrite" type="am:Ticks"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="OsISROverhead">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="preExecutionOverhead" type="am:Ticks"/>
          <xsd:element minOccurs="0" name="postExecutionOverhead" type="am:Ticks"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed" name="OperatingSystem">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="taskSchedulers" type="am:TaskScheduler"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="interruptControllers" type="am:InterruptController"/>
          <xsd:element minOccurs="0" name="osDataConsistency" type="am:OsDataConsistency"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:OsOverhead" name="overhead" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="VendorOperatingSystem">
    <xsd:complexContent>
      <xsd:extension base="am:OperatingSystem">
        <xsd:attribute name="osName" type="ecore:EString"/>
        <xsd:attribute name="vendor" type="ecore:EString"/>
        <xsd:attribute name="version" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PropertyConstraintsModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="allocationConstraints" type="am:CoreAllocationConstraint"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="mappingConstraints" type="am:MemoryMappingConstraint"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="CoreAllocationConstraint">
    <xsd:annotation>
      <xsd:documentation>Abstract Class, used to describe Constraints for Allocations
(these usually target Cores and their features/attributes)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="coreClassification" type="am:CoreClassification"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="MemoryMappingConstraint">
    <xsd:annotation>
      <xsd:documentation>Abstract Class, used to describe Constraints for Mapping
(these usually target Memories and their features/attributes)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="memoryClassification" type="am:MemoryClassification"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessAllocationConstraint">
    <xsd:annotation>
      <xsd:documentation>ProcessAllocationConstraints describe the constraints for
Process-to-Core allocations</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CoreAllocationConstraint">
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessPrototypeAllocationConstraint">
    <xsd:annotation>
      <xsd:documentation>ProcessPrototypeAllocationConstraints describe the constraints for
ProcessPrototype-to-Core allocations</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CoreAllocationConstraint">
        <xsd:attribute ecore:reference="am:ProcessPrototype" name="processPrototype" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunnableAllocationConstraint">
    <xsd:annotation>
      <xsd:documentation>RunnableAllocationConstraints describe the constraints for
Runnable-to-Core allocations</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CoreAllocationConstraint">
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AbstractElementMappingConstraint">
    <xsd:annotation>
      <xsd:documentation>AbstractElementMappingConstraints describe the constraints for
AbstractMemoryElement-to-Memory Mapping</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:MemoryMappingConstraint">
        <xsd:attribute ecore:reference="am:AbstractMemoryElement" name="abstractElement" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="Classification">
    <xsd:annotation>
      <xsd:documentation>Generalization for all Hardware related constraints</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:unsettable="false" name="condition" type="am:CombinatorialCondition"/>
        <xsd:attribute ecore:unsettable="false" name="grouping" type="am:GroupingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="CombinatorialCondition">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="requires"/>
      <xsd:enumeration ecore:value="0" value="excludes"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="GroupingType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="allOfThem"/>
      <xsd:enumeration ecore:value="0" value="atLeastOneOfThem"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="CoreClassification">
    <xsd:complexContent>
      <xsd:extension base="am:Classification">
        <xsd:attribute ecore:reference="am:CoreClassifier" name="classifiers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MemoryClassification">
    <xsd:complexContent>
      <xsd:extension base="am:Classification">
        <xsd:attribute ecore:reference="am:MemoryClassifier" name="classifiers">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StimuliModel">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="stimuli" type="am:Stimulus"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="clocks" type="am:Clock"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="Stimulus">
    <xsd:annotation>
      <xsd:documentation>Every process/task can have one or more stimuli.
A stimulus activates the process</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="setModeValueList" type="am:ModeValueList"/>
          <xsd:element minOccurs="0" name="executionCondition" type="am:ConditionDisjunction"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Process" ecore:transient="true" ecore:volatile="true" name="affectedProcesses">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of affected processes (Process).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ModeValueList">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="entries" type="am:ModeAssignment"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="ModeValueMapEntry">
    <xsd:attribute ecore:reference="am:ModeLabel" name="key" type="xsd:anyURI" use="required"/>
    <xsd:attribute name="value" type="ecore:EString" use="required"/>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ModeValue">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
        <operation name="getLiteral" type="am:ModeLiteral" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; _xblockexpression = null;
{
	&lt;%java.lang.String%&gt; _value = this.getValue();
	boolean _tripleEquals = (_value == null);
	if (_tripleEquals)
	{
		return null;
	}
	&lt;%org.eclipse.app4mc.amalthea.model.ModeLabel%&gt; _label = this.getLabel();
	&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = null;
	if (_label!=null)
	{
		_mode=_label.getMode();
	}
	final &lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; mode = _mode;
	&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; _xifexpression = null;
	if ((mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;))
	{
		final &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt; _function = new &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt;()
		{
			public &lt;%java.lang.Boolean%&gt; apply(final &lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; it)
			{
				&lt;%java.lang.String%&gt; _name = it.getName();
				&lt;%java.lang.String%&gt; _value = &lt;%this%&gt;.getValue();
				return &lt;%java.lang.Boolean%&gt;.valueOf(&lt;%com.google.common.base.Objects%&gt;.equal(_name, _value));
			}
		};
		_xifexpression = &lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;&gt;findFirst(((&lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;)mode).getLiterals(), _function);
	}
	else
	{
		_xifexpression = null;
	}
	_xblockexpression = _xifexpression;
}
return _xblockexpression;</body>
        </operation>
        <operation name="getInteger" type="ecore:EIntegerObject" unique="false">
          <body>&lt;%java.lang.Integer%&gt; _xblockexpression = null;
{
	&lt;%java.lang.String%&gt; _value = this.getValue();
	boolean _tripleEquals = (_value == null);
	if (_tripleEquals)
	{
		return null;
	}
	&lt;%org.eclipse.app4mc.amalthea.model.ModeLabel%&gt; _label = this.getLabel();
	&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = null;
	if (_label!=null)
	{
		_mode=_label.getMode();
	}
	final &lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; mode = _mode;
	&lt;%java.lang.Integer%&gt; _xifexpression = null;
	if (((mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.NumericMode%&gt;) &amp;&amp; this.getValue().matches("-?\\d+")))
	{
		_xifexpression = &lt;%java.lang.Integer%&gt;.valueOf(&lt;%java.lang.Integer%&gt;.parseInt(this.getValue()));
	}
	else
	{
		_xifexpression = null;
	}
	_xblockexpression = _xifexpression;
}
return _xblockexpression;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:ModeLabel" name="label" type="xsd:anyURI" use="required"/>
        <xsd:attribute name="value" type="ecore:EString" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ModeAssignment">
    <xsd:complexContent>
      <xsd:extension base="am:ModeValue"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ModeCondition">
    <xsd:complexContent>
      <xsd:extension base="am:Condition">
        <xsd:attribute ecore:unsettable="false" name="relation" type="am:RelationalOperator"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ModeCondition" name="ModeValueCondition">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isSatisfiedBy" type="ecore:EBoolean" unique="false">
          <parameter name="context" type="am:ModeValueMapEntry" unique="false" upperBound="-1"/>
          <body>&lt;%java.lang.String%&gt; _get = null;
if (context!=null)
{
	_get=context.get(this.getLabel());
}
final &lt;%java.lang.String%&gt; labelValue = _get;
return ((labelValue == null) || &lt;%com.google.common.base.Objects%&gt;.equal(labelValue, this.getValue()));</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ModeValue"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ModeCondition" name="ModeLabelCondition">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isSatisfiedBy" type="ecore:EBoolean" unique="false">
          <parameter name="context" type="am:ModeValueMapEntry" unique="false" upperBound="-1"/>
          <body>&lt;%java.lang.String%&gt; _get = null;
if (context!=null)
{
	_get=context.get(this.getLabel1());
}
final &lt;%java.lang.String%&gt; labelValue1 = _get;
&lt;%java.lang.String%&gt; _get_1 = null;
if (context!=null)
{
	_get_1=context.get(this.getLabel2());
}
final &lt;%java.lang.String%&gt; labelValue2 = _get_1;
return (((labelValue1 == null) || (labelValue2 == null)) || &lt;%com.google.common.base.Objects%&gt;.equal(labelValue1, labelValue2));</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:ModeLabel" name="label1" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:ModeLabel" name="label2" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ConditionDisjunction">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:ConditionDisjunctionEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ConditionDisjunctionEntry"/>
  <xsd:complexType ecore:implements="am:ConditionDisjunctionEntry" name="ConditionConjunction">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:Condition"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="Condition">
    <xsd:complexContent>
      <xsd:extension base="am:ConditionDisjunctionEntry"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:Condition" name="ChannelFillCondition">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Channel" name="channel" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="relation" type="am:RelationalOperator"/>
        <xsd:attribute ecore:unsettable="false" name="fillLevel" type="am:NonNegativeInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="FixedPeriodic">
    <xsd:annotation>
      <xsd:documentation>Stimulus that is triggered periodically.
offset: Time of first occurrence
recurrence: Time between following occurrences</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="recurrence" type="am:Time"/>
      <xsd:element minOccurs="0" name="offset" type="am:Time"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:FixedPeriodic" name="PeriodicStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus that is triggered periodically.
jitter: Deviation from true periodicity to real occurrence
minDistance: Minimal time between occurrences</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="jitter" type="am:ITimeDeviation"/>
          <xsd:element minOccurs="0" name="minDistance" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RelativePeriodicStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus that is triggered relative to the previous occurrence.
offset: Time of first occurrence
step: Time (Deviation) between successive occurrences</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="am:Time"/>
          <xsd:element name="nextOccurrence" type="am:ITimeDeviation"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="VariableRateStimulus">
    <xsd:annotation>
      <xsd:documentation>Periodic stimulus based on other events, like rotation speed
clock: Time base which defines deviation of time, multiple stimuli can have the same time base</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element name="step" type="am:Time"/>
          <xsd:element name="occurrencesPerStep" type="am:IContinuousValueDeviation"/>
          <xsd:element minOccurs="0" name="scenario" type="am:Scenario"/>
        </xsd:sequence>
        <xsd:attribute name="maxIncreasePerStep" type="ecore:EDoubleObject"/>
        <xsd:attribute name="maxDecreasePerStep" type="ecore:EDoubleObject"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Scenario">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Clock" name="clock" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0.0" ecore:unsettable="false" name="samplingOffset" type="am:NonNegativeDouble"/>
        <xsd:attribute default="1.0" ecore:unsettable="false" name="samplingRecurrence" type="am:NonNegativeDouble"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:FixedPeriodic" name="PeriodicSyntheticStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus (repeated periodically) with a defined list of occurrences.
occurrenceTimes: List of all occurrences</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="occurrenceTimes" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="CustomStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus to describe own custom types, including properties.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SingleStimulus">
    <xsd:annotation>
      <xsd:documentation>Single occurrence at a defined time.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element name="occurrence" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="InterProcessStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus based on a explicit inter process trigger.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:InterProcessTrigger" ecore:transient="true" ecore:volatile="true" name="explicitTriggers">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of triggers (InterProcessTrigger).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:FixedPeriodic" name="PeriodicBurstStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus  (repeated periodically) for burst occurrences
burstLength: Time frame for the burst (occurrences after the length are clipped)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element name="burstLength" type="am:Time"/>
          <xsd:element minOccurs="0" name="occurrenceMinDistance" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute default="1" ecore:unsettable="false" name="occurrenceCount" type="am:PositiveInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventStimulus">
    <xsd:annotation>
      <xsd:documentation>Stimulus which is activated by an event.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:TriggerEvent" name="triggeringEvents" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ArrivalCurveStimulus">
    <xsd:annotation>
      <xsd:documentation>Arrival Curve Stimulus</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Stimulus">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:ArrivalCurveEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ArrivalCurveEntry">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="lowerTimeBorder" type="am:Time"/>
          <xsd:element minOccurs="0" name="upperTimeBorder" type="am:Time"/>
        </xsd:sequence>
        <xsd:attribute default="1" ecore:unsettable="false" name="numberOfOccurrences" type="am:PositiveInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="Clock">
    <xsd:annotation>
      <xsd:documentation>Within a Scenario a Clock defines the predefined curve progression in a simulation</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ClockFunction">
    <xsd:complexContent>
      <xsd:extension base="am:Clock">
        <xsd:sequence>
          <xsd:element name="period" type="am:Time"/>
          <xsd:element name="peakToPeak" type="am:Frequency"/>
          <xsd:element minOccurs="0" name="xOffset" type="am:Time"/>
          <xsd:element minOccurs="0" name="yOffset" type="am:Frequency"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="curveType" type="am:CurveType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="CurveType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="sine"/>
      <xsd:enumeration ecore:value="0" value="triangle"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ClockStepList">
    <xsd:complexContent>
      <xsd:extension base="am:Clock">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" name="entries" type="am:ClockStep"/>
          <xsd:element minOccurs="0" name="period" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ClockStep">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element name="frequency" type="am:Frequency"/>
          <xsd:element name="time" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SWModel">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="modeLiteral" type="am:ModeLiteral" unique="false">
          <parameter name="mode" type="ecore:EString" unique="false"/>
          <parameter name="literal" type="ecore:EString" unique="false"/>
          <body>if ((&lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(mode) || &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(literal)))
{
	return null;
}
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt;&gt; _modes = this.getModes();
&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _findFirst = null;
if (_modes!=null)
{
	final &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt;, &lt;%java.lang.Boolean%&gt;&gt; _function = new &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt;, &lt;%java.lang.Boolean%&gt;&gt;()
	{
		public &lt;%java.lang.Boolean%&gt; apply(final &lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; it)
		{
			return &lt;%java.lang.Boolean%&gt;.valueOf(((it instanceof &lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;) &amp;&amp; &lt;%com.google.common.base.Objects%&gt;.equal(it.getName(), mode)));
		}
	};
	_findFirst=&lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt;&gt;findFirst(_modes, _function);
}
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;&gt; _literals = null;
if (((&lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;) _findFirst)!=null)
{
	_literals=((&lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;) _findFirst).getLiterals();
}
&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; _findFirst_1 = null;
if (_literals!=null)
{
	final &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt; _function_1 = new &lt;%org.eclipse.xtext.xbase.lib.Functions.Function1%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;, &lt;%java.lang.Boolean%&gt;&gt;()
	{
		public &lt;%java.lang.Boolean%&gt; apply(final &lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; it)
		{
			&lt;%java.lang.String%&gt; _name = it.getName();
			return &lt;%java.lang.Boolean%&gt;.valueOf(&lt;%com.google.common.base.Objects%&gt;.equal(_name, literal));
		}
	};
	_findFirst_1=&lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt;&gt;findFirst(_literals, _function_1);
}
return _findFirst_1;</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Central instance to provide central access.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="isrs" type="am:ISR"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tasks" type="am:Task"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="runnables" type="am:Runnable"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="labels" type="am:Label"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="channels" type="am:Channel"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="processPrototypes" type="am:ProcessPrototype"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="sections" type="am:Section"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="activations" type="am:Activation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="events" type="am:OsEvent"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="typeDefinitions" type="am:TypeDefinition"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="customEntities" type="am:CustomEntity"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="processChains" type="am:ProcessChain"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="modes" type="am:Mode"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="modeLabels" type="am:ModeLabel"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="AbstractMemoryElement">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="size" type="am:DataSize">
            <xsd:annotation>
              <xsd:documentation>Specifying the size of the element corresponding to the needed memory allocation</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:MemoryMapping" ecore:transient="true" ecore:volatile="true" name="mappings">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of mappings (MemoryMapping).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="AbstractProcess">
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Component" ecore:transient="true" ecore:volatile="true" name="referringComponents">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of components the abstract process belongs to.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="CustomEntity">
    <xsd:annotation>
      <xsd:documentation>Possibility to define general custom elements</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:attribute name="typeName" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProcessChain">
    <xsd:annotation>
      <xsd:documentation>Groups a list of processes to a process chain.
This does not define how the processes are chained, like being executed by one parent or like they trigger each other
This just defines that the processes should be chained.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:reference="am:Process" name="processes">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IExecutable">
    <xsd:annotation>
      <xsd:documentation>@since 1.2</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element ecore:opposite="containingExecutable" maxOccurs="unbounded" minOccurs="0" name="localLabels" type="am:LocalModeLabel"/>
      <xsd:element minOccurs="0" name="activityGraph" type="am:ActivityGraph"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:IExecutable" name="Process">
    <xsd:annotation>
      <xsd:documentation>Generalizes interrupt service routines and tasks</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractProcess">
        <xsd:attribute ecore:reference="am:Stimulus" name="stimuli">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IActivityGraphItemContainer">
    <xsd:sequence>
      <xsd:element maxOccurs="unbounded" minOccurs="0" name="items" type="am:ActivityGraphItem"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IActivityGraphItemContainer" name="ActivityGraph">
    <xsd:annotation>
      <xsd:documentation>Describes the different execution paths of a process or runnable</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ActivityGraphItem">
    <xsd:annotation>
      <xsd:documentation>An abstract item of a ActivityGraph.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:IExecutable" ecore:transient="true" ecore:volatile="true" name="containingExecutable" type="xsd:IDREF">
          <xsd:annotation>
            <xsd:documentation>@since 1.2</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Process" ecore:transient="true" ecore:volatile="true" name="containingProcess" type="xsd:IDREF">
          <xsd:annotation>
            <xsd:documentation>@deprecated Use getContainingExecutable() instead.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Runnable" ecore:transient="true" ecore:volatile="true" name="containingRunnable" type="xsd:IDREF">
          <xsd:annotation>
            <xsd:documentation>@deprecated Use getContainingExecutable() instead.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:ActivityGraph" ecore:transient="true" ecore:volatile="true" name="containingActivityGraph" type="xsd:IDREF"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Switch">
    <xsd:annotation>
      <xsd:documentation>A switch in the ActivityGraph, the selected path depends on the value of the provided conditions.

@since 2.0</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="entries" type="am:SwitchEntry"/>
          <xsd:element minOccurs="0" name="defaultEntry" type="am:SwitchDefault"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed am:IActivityGraphItemContainer" name="SwitchEntry">
    <xsd:annotation>
      <xsd:documentation>A switch entry for a Switch.
It describes a path of the switch and the required mode condition to use this path.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element name="condition" type="am:ConditionDisjunction"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IActivityGraphItemContainer" name="SwitchDefault">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ProbabilitySwitch">
    <xsd:annotation>
      <xsd:documentation>A switch in the ActivityGraph, each path has a probability.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="entries" type="am:ProbabilitySwitchEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IActivityGraphItemContainer" name="ProbabilitySwitchEntry">
    <xsd:annotation>
      <xsd:documentation>A switch entry for a ProbabilitySwitch.
It describes a path of the switch and it's probability.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute default="0.0" ecore:unsettable="false" name="probability" type="ecore:EDouble"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IActivityGraphItemContainer" name="WhileLoop">
    <xsd:annotation>
      <xsd:documentation>A While loop in the ActivityGraph.
The (repeated) execution depends on the value of the provided mode conditions.

@since 1.2</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element name="condition" type="am:ConditionDisjunction"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Counter">
    <xsd:annotation>
      <xsd:documentation>A counter for the call sequence items</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute default="1" ecore:unsettable="false" name="prescaler" type="am:PositiveLong"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="offset" type="am:NonNegativeLong"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="WaitEvent">
    <xsd:annotation>
      <xsd:documentation>Let the process wait for a combination of events defined by eventMask
maskType defines if the events in eventMask are linked by a AND or OR</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="eventMask" type="am:EventMask"/>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="maskType" type="am:WaitEventType"/>
        <xsd:attribute ecore:unsettable="false" name="waitingBehaviour" type="am:WaitingBehaviour"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="WaitEventType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="AND"/>
      <xsd:enumeration ecore:value="0" value="OR"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="WaitingBehaviour">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="active"/>
      <xsd:enumeration ecore:value="0" value="passive"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="SetEvent">
    <xsd:annotation>
      <xsd:documentation>Sets the events of eventMask
These events can be set for a specific process, if there is no process, is is global (for all processes)
If there is a process, it is possible to set the event for a specific process instance that is currently activated</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="eventMask" type="am:EventMask"/>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Process" name="process" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ClearEvent">
    <xsd:annotation>
      <xsd:documentation>Clears the events of eventMask</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="eventMask" type="am:EventMask"/>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventMask">
    <xsd:annotation>
      <xsd:documentation>A event mask</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:OsEvent" name="events">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="OsEvent">
    <xsd:annotation>
      <xsd:documentation>A event that can be set, cleared and waited for by a process</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute default="0" ecore:unsettable="false" name="communicationOverheadInBit" type="ecore:EInt"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Component" ecore:transient="true" ecore:volatile="true" name="referringComponents">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of components the OS event belongs to.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="InterProcessTrigger">
    <xsd:annotation>
      <xsd:documentation>Triggers a stimulus to activate its processes</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:InterProcessStimulus" name="stimulus" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EnforcedMigration">
    <xsd:annotation>
      <xsd:documentation>Migrates task to core of resource owner</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:TaskScheduler" name="resourceOwner" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SchedulePoint">
    <xsd:annotation>
      <xsd:documentation>Triggers scheduler</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TerminateProcess">
    <xsd:annotation>
      <xsd:documentation>Terminates the process</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Task">
    <xsd:annotation>
      <xsd:documentation>Schedulable entity, which is managed by the OS. An instance of a Task is mapped to exactly one core
and includes the direct representation of all abstractions.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Process">
        <xsd:attribute ecore:unsettable="false" name="preemption" type="am:Preemption"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="multipleTaskActivationLimit" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ISR">
    <xsd:annotation>
      <xsd:documentation>Interrupt service routine</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Process">
        <xsd:attribute ecore:unsettable="false" name="category" type="am:ISRCategory"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ISRCategory">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="CATEGORY_1"/>
      <xsd:enumeration ecore:value="0" value="CATEGORY_2"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ProcessPrototype">
    <xsd:annotation>
      <xsd:documentation>Prototype class for Process.
It does contain meta information of potential processes, which does not represent the final state.
The final state can be several Tasks, which can be computed using provided information of this prototype.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractProcess">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="accessPrecedenceSpec" type="am:AccessPrecedenceSpec">
            <xsd:annotation>
              <xsd:documentation>Defines the general label accesses</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="orderPrecedenceSpec" type="am:OrderPrecedenceSpec">
            <xsd:annotation>
              <xsd:documentation>Defines the general order of runnables</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="chainedPrototypes" type="am:ChainedProcessPrototype"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="runnableCalls" type="am:RunnableCall"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="preemption" type="am:Preemption"/>
        <xsd:attribute ecore:reference="am:Runnable" name="firstRunnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="lastRunnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Activation" name="activation" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ChainedProcessPrototype">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:ProcessPrototype" name="prototype" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="apply" type="ecore:EInt"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="offset" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="GeneralPrecedence">
    <xsd:annotation>
      <xsd:documentation>General abstraction for precedence</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Runnable" name="origin" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Runnable" name="target" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AccessPrecedenceSpec">
    <xsd:complexContent>
      <xsd:extension base="am:GeneralPrecedence">
        <xsd:attribute ecore:reference="am:Label" name="label" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="orderType" type="am:AccessPrecedenceType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="AccessPrecedenceType">
    <xsd:annotation>
      <xsd:documentation>Defines the access precedence at the time of one task period.</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="defaultWR">
        <xsd:annotation>
          <xsd:documentation>Writer of label has to be performed before the reader.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="ignoreWR">
        <xsd:annotation>
          <xsd:documentation>Dependency between writer and reader can be ignored.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="enforceRW">
        <xsd:annotation>
          <xsd:documentation>Reader of label has to be performed before the writer (delay unit of controller).</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="OrderPrecedenceSpec">
    <xsd:complexContent>
      <xsd:extension base="am:GeneralPrecedence">
        <xsd:attribute ecore:unsettable="false" name="orderType" type="am:OrderType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="OrderType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="order">
        <xsd:annotation>
          <xsd:documentation>Defines a general order, the included elements must not follow directly</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="directOrder">
        <xsd:annotation>
          <xsd:documentation>The defined elements must follow directly</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="startSequence"/>
      <xsd:enumeration ecore:value="0" value="endSequence"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DirectionType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="in"/>
      <xsd:enumeration ecore:value="0" value="out"/>
      <xsd:enumeration ecore:value="0" value="inout"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" ecore:interface="true" name="IDependsOn">
    <xsd:sequence>
      <xsd:element minOccurs="0" name="dependsOn" type="am:DataDependency"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="DataDependency">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:Label" name="labels">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:RunnableParameter" name="parameters">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:CallArgument" name="callArguments">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Runnable" ecore:transient="true" ecore:volatile="true" name="containingRunnable" type="xsd:IDREF"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDependsOn" name="RunnableParameter">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.Runnable%&gt; _containingRunnable = this.getContainingRunnable();
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_containingRunnable!=null)
{
	_qualifiedNameSegments=_containingRunnable.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	&lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _newBasicEList = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	_elvis = _newBasicEList;
}
return _elvis;</body>
        </operation>
        <operation name="toString" type="ecore:EString" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.Runnable%&gt; _containingRunnable = this.getContainingRunnable();
&lt;%java.lang.String%&gt; _name = null;
if (_containingRunnable!=null)
{
	_name=_containingRunnable.getName();
}
final &lt;%java.lang.String%&gt; runName = _name;
&lt;%java.lang.String%&gt; _xifexpression = null;
boolean _isNullOrEmpty = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(runName);
if (_isNullOrEmpty)
{
	_xifexpression = "&lt;runnable&gt;";
}
else
{
	_xifexpression = runName;
}
&lt;%java.lang.String%&gt; _plus = (_xifexpression + "::");
&lt;%java.lang.String%&gt; _xifexpression_1 = null;
boolean _isNullOrEmpty_1 = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(this.getName());
if (_isNullOrEmpty_1)
{
	_xifexpression_1 = "&lt;parameter&gt;";
}
else
{
	_xifexpression_1 = this.getName();
}
return (_plus + _xifexpression_1);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="parameters" ecore:reference="am:Runnable" name="containingRunnable" type="xsd:anyURI"/>
        <xsd:attribute ecore:unsettable="false" name="direction" type="am:DirectionType"/>
        <xsd:attribute ecore:reference="am:TypeDefinition" name="dataType" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IExecutable am:INamespaceMember" name="Runnable">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getRunnableItems" type="am:ActivityGraphItem" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%org.eclipse.app4mc.amalthea.model.ActivityGraphItem%&gt;&gt; _xblockexpression = null;
{
	&lt;%org.eclipse.app4mc.amalthea.model.ActivityGraph%&gt; _activityGraph = this.getActivityGraph();
	boolean _tripleEquals = (_activityGraph == null);
	if (_tripleEquals)
	{
		this.setActivityGraph(&lt;%org.eclipse.app4mc.amalthea.model.AmaltheaFactory%&gt;.eINSTANCE.createActivityGraph());
	}
	_xblockexpression = this.getActivityGraph().getItems();
}
return _xblockexpression;</body>
        </operation>
        <operation name="getFirstActivation" type="am:Activation" unique="false">
          <body>return &lt;%org.eclipse.xtext.xbase.lib.IterableExtensions%&gt;.&lt;&lt;%org.eclipse.app4mc.amalthea.model.Activation%&gt;&gt;head(this.getActivations());</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Smallest allocatable unit, which provides additional (optional) attributes for allocation algorithms.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="executionCondition" type="am:ConditionDisjunction"/>
          <xsd:element ecore:opposite="containingRunnable" maxOccurs="unbounded" minOccurs="0" name="parameters" type="am:RunnableParameter"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Activation" name="activations">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute default="false" ecore:unsettable="false" name="callback" type="ecore:EBoolean">
          <xsd:annotation>
            <xsd:documentation>Marker if runnable is used as callback.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute default="false" ecore:unsettable="false" name="service" type="ecore:EBoolean">
          <xsd:annotation>
            <xsd:documentation>Marker if runnable is used as a service.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="asilLevel" type="am:ASILType">
          <xsd:annotation>
            <xsd:documentation>ASIL level for the runnable entity</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:reference="am:Section" name="section" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:RunnableCall" ecore:transient="true" ecore:volatile="true" name="runnableCalls">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of callers (RunnableCalls).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Component" ecore:transient="true" ecore:volatile="true" name="referringComponents">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of components the runnable belongs to.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDisplayName am:INamespaceMember" name="Label">
    <xsd:annotation>
      <xsd:documentation>Data representation, which can be accessed by run entities.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:attribute ecore:reference="am:TypeDefinition" name="dataType" type="xsd:anyURI"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="constant" type="ecore:EBoolean">
          <xsd:annotation>
            <xsd:documentation>Defines the label as a constant, not modifiable entity</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute default="false" ecore:unsettable="false" name="bVolatile" type="ecore:EBoolean">
          <xsd:annotation>
            <xsd:documentation>Defines if the label value is volatile or persistent to survive shutdown and start of system</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="dataStability" type="am:LabelDataStability">
          <xsd:annotation>
            <xsd:documentation>Defines the data stability needs of the label</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="stabilityLevel" type="am:DataStabilityLevel"/>
        <xsd:attribute ecore:reference="am:Section" name="section" type="xsd:anyURI"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:LabelAccess" ecore:transient="true" ecore:volatile="true" name="labelAccesses">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of accesses (LabelAccess).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Component" ecore:transient="true" ecore:volatile="true" name="referringComponents">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of components the label belongs to.
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDisplayName am:INamespaceMember" name="Channel">
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:attribute ecore:reference="am:TypeDefinition" name="elementType" type="xsd:anyURI"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="defaultElements" type="ecore:EInt"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="maxElements" type="ecore:EInt"/>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:ChannelAccess" ecore:transient="true" ecore:volatile="true" name="channelAccesses">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of accesses (ChannelAccess).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDisplayName" name="ModeLabel">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = this.getMode();
return (_mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;);</body>
        </operation>
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = this.getMode();
return (_mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.NumericMode%&gt;);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:AbstractMemoryElement">
        <xsd:attribute ecore:reference="am:Mode" name="mode" type="xsd:anyURI" use="required"/>
        <xsd:attribute name="initialValue" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="LabelDataStability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="noProtection"/>
      <xsd:enumeration ecore:value="0" value="automaticProtection"/>
      <xsd:enumeration ecore:value="0" value="customProtection"/>
      <xsd:enumeration ecore:value="0" value="handledByModelElements"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="Section">
    <xsd:annotation>
      <xsd:documentation>A section is a logical structure, which contains labels and abstract run entities.
It is used to provide an easy mechanism to distribute objects to memory,
which are belonging together.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:unsettable="false" name="asilLevel" type="am:ASILType">
          <xsd:annotation>
            <xsd:documentation>for specifying the ASIL level for the "virtual memory sections"</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Label" ecore:transient="true" ecore:volatile="true" name="labels">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of labels (Label).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:changeable="false" ecore:derived="true" ecore:reference="am:Runnable" ecore:transient="true" ecore:volatile="true" name="runnables">
          <xsd:annotation>
            <xsd:documentation>
              <p>
                <b>
                  Returns an 
                  <em>immutable</em>
                   list of runnables (Runnable).
                </b>
              </p>
            </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ComputationItem">
    <xsd:annotation>
      <xsd:documentation>Representation of a object that describes computation</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ExecutionNeed">
    <xsd:annotation>
      <xsd:documentation>Representation of the execution needs of a Runnable (default and core-specific)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="needs" type="am:NeedEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="NeedEntry">
    <xsd:sequence>
      <xsd:element name="value" type="am:IDiscreteValueDeviation"/>
    </xsd:sequence>
    <xsd:attribute name="key" type="ecore:EString" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="Ticks">
    <xsd:annotation>
      <xsd:documentation>Representation of the execution IDiscreteValueDeviation of a Runnable (default and core-specific)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ComputationItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="default" type="am:IDiscreteValueDeviation"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="extended" type="am:TicksEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:instanceClass="java.util.Map$Entry" name="TicksEntry">
    <xsd:sequence>
      <xsd:element name="value" type="am:IDiscreteValueDeviation"/>
    </xsd:sequence>
    <xsd:attribute ecore:reference="am:ProcessingUnitDefinition" name="key" type="xsd:anyURI" use="required"/>
  </xsd:complexType>
  <xsd:simpleType name="ModeLabelAccessEnum">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="read"/>
      <xsd:enumeration ecore:value="0" value="set"/>
      <xsd:enumeration ecore:value="0" value="increment"/>
      <xsd:enumeration ecore:value="0" value="decrement"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ModeLabelAccess">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
      <xsd:documentation>Representation of a mode label access of a run entity.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:ModeLabel" name="data" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="access" type="am:ModeLabelAccessEnum"/>
        <xsd:attribute name="value" type="ecore:EString">
          <xsd:annotation>
            <xsd:documentation>Just used in case that this access writes a value to a Mode-Label.
It can be used to define which mode value is written to the label.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute default="1" ecore:unsettable="false" name="step" type="am:PositiveInt">
          <xsd:annotation>
            <xsd:documentation>Just used in case of increment or decrement.
It can be used to define a step other than 1.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable am:IDependsOn" name="LabelAccess">
    <xsd:annotation>
      <xsd:documentation>Representation of a label access of a run entity.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ComputationItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="statistic" type="am:LabelAccessStatistic">
            <xsd:annotation>
              <xsd:documentation>Optional parameter for statistic values</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element minOccurs="0" name="transmissionPolicy" type="am:TransmissionPolicy">
            <xsd:annotation>
              <xsd:documentation>Optional parameter for transmission policy of larger data</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Label" name="data" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="access" type="am:LabelAccessEnum"/>
        <xsd:attribute ecore:unsettable="false" name="dataStability" type="am:LabelAccessDataStability">
          <xsd:annotation>
            <xsd:documentation>Defines the data stability needs of the label access</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute ecore:unsettable="false" name="implementation" type="am:LabelAccessImplementation"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ChannelAccess">
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="transmissionPolicy" type="am:TransmissionPolicy"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Channel" name="data" type="xsd:anyURI" use="required"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="elements" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ChannelSend">
    <xsd:complexContent>
      <xsd:extension base="am:ChannelAccess"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ChannelReceive">
    <xsd:complexContent>
      <xsd:extension base="am:ChannelAccess">
        <xsd:attribute ecore:unsettable="false" name="receiveOperation" type="am:ReceiveOperation"/>
        <xsd:attribute default="false" ecore:unsettable="false" name="dataMustBeNew" type="ecore:EBoolean"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="elementIndex" type="ecore:EInt"/>
        <xsd:attribute default="0" ecore:unsettable="false" name="lowerBound" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ReceiveOperation">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="FIFO_Read"/>
      <xsd:enumeration ecore:value="0" value="FIFO_Take"/>
      <xsd:enumeration ecore:value="0" value="LIFO_Read"/>
      <xsd:enumeration ecore:value="0" value="LIFO_Take"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LabelAccessDataStability">
    <xsd:annotation>
      <xsd:documentation>Defines the data stability needs of a label access.
Inherited means that the setting of the Label is used</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="inherited"/>
      <xsd:enumeration ecore:value="0" value="noProtection"/>
      <xsd:enumeration ecore:value="0" value="automaticProtection"/>
      <xsd:enumeration ecore:value="0" value="customProtection"/>
      <xsd:enumeration ecore:value="0" value="handledByModelElements"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LabelAccessEnum">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="read"/>
      <xsd:enumeration ecore:value="0" value="write"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LabelAccessImplementation">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="explicit"/>
      <xsd:enumeration ecore:value="0" value="implicit"/>
      <xsd:enumeration ecore:value="0" value="timed"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="SemaphoreAccess">
    <xsd:annotation>
      <xsd:documentation>Describes an semaphore access</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:Semaphore" name="semaphore" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:unsettable="false" name="access" type="am:SemaphoreAccessEnum"/>
        <xsd:attribute ecore:unsettable="false" name="waitingBehaviour" type="am:WaitingBehaviour"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="SemaphoreAccessEnum">
    <xsd:annotation>
      <xsd:documentation>request: requests access to semaphore
release: release accessed semaphore
exclusive: gets access to requested semaphore only when there is no other user accessing it</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="request"/>
      <xsd:enumeration ecore:value="0" value="exclusive"/>
      <xsd:enumeration ecore:value="0" value="release"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" name="SenderReceiverCommunication">
    <xsd:annotation>
      <xsd:documentation>An abstract description for sender-receiver-communication (it can be read or write)</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute default="false" ecore:unsettable="false" name="buffered" type="ecore:EBoolean"/>
        <xsd:attribute ecore:reference="am:Label" name="label" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:ComponentPort" name="port" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SenderReceiverRead">
    <xsd:annotation>
      <xsd:documentation>The read operation of the receiver of the sender-receiver-communication</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SenderReceiverCommunication"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SenderReceiverWrite">
    <xsd:annotation>
      <xsd:documentation>The write operation of the sender of the sender-receiver-communication
It contains the runnables that have the corresponding SenderReceiverRead</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:SenderReceiverCommunication">
        <xsd:attribute ecore:reference="am:Runnable" name="notifiedRunnables">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="ServerCall">
    <xsd:annotation>
      <xsd:documentation>An abstract description for client/server communication
It refers to a required runnable that describes the called server operation</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:Runnable" name="serverRunnable" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:ComponentPort" name="port" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SynchronousServerCall">
    <xsd:annotation>
      <xsd:documentation>A synchronous server call</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ServerCall">
        <xsd:attribute ecore:unsettable="false" name="waitingBehaviour" type="am:WaitingBehaviour"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AsynchronousServerCall">
    <xsd:annotation>
      <xsd:documentation>A asynchronous server call
It refers to a optional runnable that exploits the results produced by the server</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ServerCall">
        <xsd:attribute ecore:reference="am:Runnable" name="resultRunnable" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GetResultServerCall">
    <xsd:annotation>
      <xsd:documentation>Get the result of a previous asynchronous server call</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ServerCall">
        <xsd:attribute ecore:unsettable="false" name="blockingType" type="am:BlockingType"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="BlockingType">
    <xsd:annotation>
      <xsd:documentation>Blocking type</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="active_wait"/>
      <xsd:enumeration ecore:value="0" value="passive_wait"/>
      <xsd:enumeration ecore:value="0" value="non_blocking"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType ecore:implements="am:INamed am:IActivityGraphItemContainer" name="Group">
    <xsd:annotation>
      <xsd:documentation>Describes a group of deviation runnable items</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute default="true" ecore:unsettable="false" name="ordered" type="ecore:EBoolean"/>
        <xsd:attribute default="true" ecore:unsettable="false" name="interruptible" type="ecore:EBoolean">
          <xsd:annotation>
            <xsd:documentation>@since 1.2</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDependsOn" name="CallArgument">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getName" type="ecore:EString" unique="false">
          <body>&lt;%java.lang.String%&gt; _xifexpression = null;
boolean _isNullOrEmpty = &lt;%org.eclipse.xtext.xbase.lib.StringExtensions%&gt;.isNullOrEmpty(super.getName());
if (_isNullOrEmpty)
{
	_xifexpression = "access-1";
}
else
{
	_xifexpression = super.getName();
}
return _xifexpression;</body>
        </operation>
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>final &lt;%org.eclipse.emf.common.util.BasicEList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; segments = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
&lt;%org.eclipse.app4mc.amalthea.model.RunnableCall%&gt; _containingCall = this.getContainingCall();
&lt;%org.eclipse.app4mc.amalthea.model.ActivityGraph%&gt; _containingActivityGraph = null;
if (_containingCall!=null)
{
	_containingActivityGraph=_containingCall.getContainingActivityGraph();
}
&lt;%org.eclipse.emf.ecore.EObject%&gt; _eContainer = null;
if (_containingActivityGraph!=null)
{
	_eContainer=_containingActivityGraph.eContainer();
}
final &lt;%org.eclipse.app4mc.amalthea.model.IReferable%&gt; runnableOrProcess = ((&lt;%org.eclipse.app4mc.amalthea.model.IReferable%&gt;) _eContainer);
if ((runnableOrProcess != null))
{
	segments.addAll(runnableOrProcess.getQualifiedNameSegments());
}
segments.add("calls");
&lt;%java.util.List%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _elvis = null;
&lt;%org.eclipse.app4mc.amalthea.model.RunnableCall%&gt; _containingCall_1 = this.getContainingCall();
&lt;%org.eclipse.app4mc.amalthea.model.Runnable%&gt; _runnable = null;
if (_containingCall_1!=null)
{
	_runnable=_containingCall_1.getRunnable();
}
&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _qualifiedNameSegments = null;
if (_runnable!=null)
{
	_qualifiedNameSegments=_runnable.getQualifiedNameSegments();
}
if (_qualifiedNameSegments != null)
{
	_elvis = _qualifiedNameSegments;
} else
{
	_elvis = java.util.Collections.&lt;&lt;%java.lang.String%&gt;&gt;unmodifiableList(org.eclipse.xtext.xbase.lib.CollectionLiterals.&lt;&lt;%java.lang.String%&gt;&gt;newArrayList(""));
}
segments.addAll(_elvis);
segments.add("param");
&lt;%java.lang.String%&gt; _elvis_1 = null;
&lt;%org.eclipse.app4mc.amalthea.model.RunnableParameter%&gt; _parameter = this.getParameter();
&lt;%java.lang.String%&gt; _name = null;
if (_parameter!=null)
{
	_name=_parameter.getName();
}
if (_name != null)
{
	_elvis_1 = _name;
} else
{
	_elvis_1 = "";
}
segments.add(_elvis_1);
return segments;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="arguments" ecore:reference="am:RunnableCall" name="containingCall" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:RunnableParameter" name="parameter" type="xsd:anyURI"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="RunnableCall">
    <xsd:annotation>
      <xsd:documentation>Representation of a runnable call of a run entity.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:sequence>
          <xsd:element ecore:opposite="containingCall" maxOccurs="unbounded" minOccurs="0" name="arguments" type="am:CallArgument"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="context" type="am:LocalModeLabelAssignment"/>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
          <xsd:element minOccurs="0" name="statistic" type="am:RunEntityCallStatistic"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:Runnable" name="runnable" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="Preemption">
    <xsd:annotation>
      <xsd:documentation>Preemption type for scheduling</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="preemptive"/>
      <xsd:enumeration ecore:value="0" value="cooperative"/>
      <xsd:enumeration ecore:value="0" value="non_preemptive"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ConcurrencyType">
    <xsd:annotation>
      <xsd:documentation>Concurrency type of an entity</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="SingleCoreSafe">
        <xsd:annotation>
          <xsd:documentation>Safe for access inside of the same core</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="MultiCoreSafe">
        <xsd:annotation>
          <xsd:documentation>Safe for access from another core</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration ecore:value="0" value="SingleCorePrioSafe"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="CustomEventTrigger">
    <xsd:annotation>
      <xsd:documentation>Explicitly trigger a custom event from a runnable.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:CustomEvent" name="event" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="DataType">
    <xsd:annotation>
      <xsd:documentation>Central access point for different data type definitions</xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:DataType" name="CompoundType">
    <xsd:annotation>
      <xsd:documentation>Couple of compound data types</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ITaggable" name="Struct">
    <xsd:annotation>
      <xsd:documentation>Representing a struct definition, containing different entries</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CompoundType">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="entries" type="am:StructEntry"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:INamed am:ITaggable" name="StructEntry">
    <xsd:annotation>
      <xsd:documentation>Representation of one struct entry</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="dataType" type="am:DataType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Array">
    <xsd:annotation>
      <xsd:documentation>Representation of an array data type</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CompoundType">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="dataType" type="am:DataType"/>
        </xsd:sequence>
        <xsd:attribute default="0" ecore:unsettable="false" name="numberElements" type="ecore:EInt"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Pointer">
    <xsd:annotation>
      <xsd:documentation>Representing a pointer</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:CompoundType">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="dataType" type="am:DataType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:DataType" name="TypeRef">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute ecore:reference="am:TypeDefinition" name="typeDef" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Alias">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:attribute name="target" type="ecore:EString">
          <xsd:annotation>
            <xsd:documentation>Name of the target environment</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="alias" type="ecore:EString">
          <xsd:annotation>
            <xsd:documentation>Corresponding name in the target environment</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:INamespaceMember" name="TypeDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="size" type="am:DataSize">
            <xsd:annotation>
              <xsd:documentation>Size of the defined data type</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DataTypeDefinition">
    <xsd:complexContent>
      <xsd:extension base="am:TypeDefinition">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="dataType" type="am:DataType"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BaseTypeDefinition">
    <xsd:annotation>
      <xsd:documentation>Basic data type definition, including naming (alias) in target environments</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:TypeDefinition">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="aliases" type="am:Alias">
            <xsd:annotation>
              <xsd:documentation>Naming in different target environments</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:implements="am:ITaggable" name="Activation">
    <xsd:annotation>
      <xsd:documentation>General abstraction for activation source.
Used for first definition of an activation rate, which is later refined by stimulus.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PeriodicActivation">
    <xsd:annotation>
      <xsd:documentation>Min and Max execution frequency within a task or timeslice</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Activation">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="min" type="am:Time"/>
          <xsd:element minOccurs="0" name="max" type="am:Time"/>
          <xsd:element name="recurrence" type="am:Time"/>
          <xsd:element minOccurs="0" name="offset" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="VariableRateActivation">
    <xsd:annotation>
      <xsd:documentation>Periodic activation based on other events, like rotation speed</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Activation">
        <xsd:sequence>
          <xsd:element name="step" type="am:Time"/>
          <xsd:element name="occurrencesPerStep" type="am:IContinuousValueDeviation"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="SporadicActivation">
    <xsd:complexContent>
      <xsd:extension base="am:Activation">
        <xsd:sequence>
          <xsd:element name="occurrence" type="am:ITimeDeviation"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SingleActivation">
    <xsd:annotation>
      <xsd:documentation>A single activation between time min and max</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Activation">
        <xsd:sequence>
          <xsd:element name="min" type="am:Time"/>
          <xsd:element name="max" type="am:Time"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EventActivation">
    <xsd:annotation>
      <xsd:documentation>Activation which is triggered by an event.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:Activation">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="counter" type="am:Counter"/>
        </xsd:sequence>
        <xsd:attribute ecore:reference="am:TriggerEvent" name="triggeringEvents" use="required">
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:IDescription" name="CustomActivation">
    <xsd:complexContent>
      <xsd:extension base="am:Activation"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LabelAccessStatistic">
    <xsd:annotation>
      <xsd:documentation>Contains information about access statistic values</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="am:NumericStatistic"/>
          <xsd:element minOccurs="0" name="cacheMisses" type="am:NumericStatistic"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RunEntityCallStatistic">
    <xsd:complexContent>
      <xsd:extension base="am:BaseObject">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="statistic" type="am:NumericStatistic"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ASILType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="D"/>
      <xsd:enumeration ecore:value="0" value="C"/>
      <xsd:enumeration ecore:value="0" value="B"/>
      <xsd:enumeration ecore:value="0" value="A"/>
      <xsd:enumeration ecore:value="0" value="QM"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="LocalModeLabel">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="getNamePrefixSegments" type="ecore:EString" unique="false" upperBound="-1">
          <body>&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _xblockexpression = null;
{
	final &lt;%org.eclipse.app4mc.amalthea.model.IExecutable%&gt; exe = this.getContainingExecutable();
	&lt;%org.eclipse.emf.common.util.EList%&gt;&lt;&lt;%java.lang.String%&gt;&gt; _xifexpression = null;
	if ((exe instanceof &lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt;))
	{
		_xifexpression = ((&lt;%org.eclipse.app4mc.amalthea.model.INamed%&gt;)exe).getQualifiedNameSegments();
	}
	else
	{
		_xifexpression = &lt;%org.eclipse.emf.ecore.xcore.lib.XcoreCollectionLiterals%&gt;.&lt;&lt;%java.lang.String%&gt;&gt;newBasicEList();
	}
	_xblockexpression = _xifexpression;
}
return _xblockexpression;</body>
        </operation>
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = this.getMode();
return (_mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt;);</body>
        </operation>
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = this.getMode();
return (_mode instanceof &lt;%org.eclipse.app4mc.amalthea.model.NumericMode%&gt;);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ReferableBaseObject">
        <xsd:attribute ecore:changeable="false" ecore:opposite="localLabels" ecore:reference="am:IExecutable" name="containingExecutable" type="xsd:anyURI"/>
        <xsd:attribute ecore:reference="am:Mode" name="mode" type="xsd:anyURI" use="required"/>
        <xsd:attribute name="defaultValue" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="LocalModeValue">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="valueSource" type="am:ILocalModeValueSource"/>
    </xsd:sequence>
    <xsd:attribute ecore:reference="am:LocalModeLabel" name="label" type="xsd:anyURI" use="required"/>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:ActivityGraphItem" name="LocalModeLabelAssignment">
    <xsd:complexContent>
      <xsd:extension base="am:LocalModeValue"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType ecore:implements="am:Condition am:IAnnotatable" name="LocalModeCondition">
    <xsd:complexContent>
      <xsd:extension base="am:LocalModeValue">
        <xsd:attribute ecore:unsettable="false" name="relation" type="am:RelationalOperator"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" ecore:interface="true" name="ILocalModeValueSource">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>return false;</body>
        </operation>
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return false;</body>
        </operation>
        <operation name="getMode" type="am:Mode" unique="false">
          <body>return null;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType name="ModeLiteralConst">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>return true;</body>
        </operation>
        <operation name="getMode" type="am:Mode" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.ModeLiteral%&gt; _value = this.getValue();
&lt;%org.eclipse.app4mc.amalthea.model.EnumMode%&gt; _containingMode = null;
if (_value!=null)
{
	_containingMode=_value.getContainingMode();
}
return _containingMode;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:attribute ecore:reference="am:ModeLiteral" name="value" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IntegerConst">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return true;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:attribute ecore:default="0" ecore:unsettable="false" name="value" type="ecore:EInt" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ModeLabelRef">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>return this.getValue().isEnum();</body>
        </operation>
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return this.getValue().isNumeric();</body>
        </operation>
        <operation name="getMode" type="am:Mode" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.ModeLabel%&gt; _value = this.getValue();
&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = null;
if (_value!=null)
{
	_mode=_value.getMode();
}
return _mode;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:attribute ecore:reference="am:ModeLabel" name="value" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LocalModeLabelRef">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isEnum" type="ecore:EBoolean" unique="false">
          <body>return this.getValue().isEnum();</body>
        </operation>
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return this.getValue().isNumeric();</body>
        </operation>
        <operation name="getMode" type="am:Mode" unique="false">
          <body>&lt;%org.eclipse.app4mc.amalthea.model.LocalModeLabel%&gt; _value = this.getValue();
&lt;%org.eclipse.app4mc.amalthea.model.Mode%&gt; _mode = null;
if (_value!=null)
{
	_mode=_value.getMode();
}
return _mode;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:attribute ecore:reference="am:LocalModeLabel" name="value" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ChannelFillRef">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return true;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:attribute ecore:reference="am:Channel" name="value" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ArithmeticExpression">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="isNumeric" type="ecore:EBoolean" unique="false">
          <body>return true;</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ILocalModeValueSource">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="operand1" type="am:ILocalModeValueSource"/>
          <xsd:element minOccurs="0" name="operand2" type="am:ILocalModeValueSource"/>
        </xsd:sequence>
        <xsd:attribute ecore:unsettable="false" name="operator" type="am:ArithmeticOperator"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ArithmeticOperator">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="_undefined_"/>
      <xsd:enumeration ecore:value="0" value="ADD"/>
      <xsd:enumeration ecore:value="0" value="SUBTRACT"/>
      <xsd:enumeration ecore:value="0" value="MULTIPLY"/>
      <xsd:enumeration ecore:value="0" value="MODULO"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ModeLabelAssignment">
    <xsd:annotation>
      <xsd:appinfo ecore:key="operations" source="http://www.eclipse.org/emf/2002/Ecore">
        <operation name="validateInvariants" type="ecore:EBoolean" unique="false">
          <parameter name="diagnostics" type="ecore:EDiagnosticChain" unique="false"/>
          <parameter name="context" type="ecore:EMap{ecore:EJavaObject, ecore:EJavaObject}" unique="false"/>
          <body>return &lt;%org.eclipse.app4mc.amalthea.model.AmaltheaValidations%&gt;.validateInvariants(this, diagnostics);</body>
        </operation>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="am:ActivityGraphItem">
        <xsd:attribute ecore:reference="am:ModeLabel" name="globalLabel" type="xsd:anyURI" use="required"/>
        <xsd:attribute ecore:reference="am:LocalModeLabel" name="localLabel" type="xsd:anyURI" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>
